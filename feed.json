{"title":"Aotu.io","description":"凹凸实验室(Aotu.io) 始建于2015年，是一个年轻基情的技术社区组织。<br/>O2面向多终端技术体系，致力于构建沉淀与分享包括但不限于交互、页面制作技巧、前端开发、原生APP开发等方面的专业知识及案例。","language":"zh-cn","link":"https://aotu.io","pubDate":"Thu, 05 Nov 2020 07:40:20 GMT","lastBuildDate":"Thu, 05 Nov 2020 08:20:09 GMT","generator":"hexo-generator-json-feed","webMaster":"凹凸实验室","items":[{"title":"EaseJs中regX/regY的用法","link":"https://aotu.io/notes/2020/11/05/easeJs-center-setting/","description":"前情提要动效开发中最常用的基本变形动作就是缩放、旋转等，该变形会涉及到中心点的设置。由于我们采用了createJs中的easeJs库进行图形绘制，这个时候我们就会用到regX/regY。下面先看一个小demo: 我们先在页面中画一个100x100的矩形，并放置在canvas中间，代码如下：123456789101112131415161718192021222324252627282930313233import React, &#123; useRef, useEffect &#125; from \"react\";import &#123; Power0, TweenMax as Tween &#125; from \"gsap\";import &#123; Stage, Shape, Graphics, Ticker &#125; from \"@createjs/easeljs\";import \"./App.css\";function MotionDemo() &#123; const canvasRef = useRef(null); Tween.ticker.fps(24); useEffect(() =&gt; &#123; canvasRef.current.width = 400; canvasRef.current.height = 400; let stage; window.stage = stage = new Stage(canvasRef.current); const graphics = new Graphics().beginFill(\"#0ff\").drawRect(0, 0, 100, 100); const shape = new Shape(graphics); window.stage.addChild(shape); //将矩形放置在canvas中 shape.x = 150; shape.y = 150; shape.alpha = 0.3; Ticker.on(\"tick\", e =&gt; &#123; stage.update(); &#125;); &#125;, []); return ( &lt;div style=&#123;&#123; position: \"relative\", width: \"100%\", height: \"100%\" &#125;&#125;&gt; &lt;div style=&#123;&#123; position: \"absolute\", left: \"10%\", top: \"20%\" &#125;&#125;&gt; &lt;canvas className=\"canvas\" ref=&#123;canvasRef&#125; width=&#123;200&#125; height=&#123;200&#125; /&gt; &lt;/div&gt; &lt;/div&gt; );&#125;export default MotionDemo 效果如下： ^_^ 继续说回regX/regY什么是regX/regY 官方文档解释： regX：The left offset for this display object’s registration point.即该显示对象注册点的左偏移量。 regY:The y offset for this display object’s registration point.即该显示对象注册点的上偏移量。 需要明确的是： regX/regY为正时，对象往左上偏移；regX/regY为负，则向右下偏移。现在我们让中间的矩形动起来,向useEffect 底部添加如下代码:12345Tween.to(shape, 2, &#123; rotation: 360, repeat: -1, ease: Power0.easeNone, &#125;) 效果如下： 很显然我们能发现，该对象的注册点即左顶点。 设置regX/regY绕图形中心旋转 官方说明： For example, to make a 100x100px Bitmap rotate around its center, you would set regX and regY to 50.让一个100x100的矩形，围绕起中心点旋转，则需要将regX/regY设为50. 现在我们设置regX/regY，显示对象宽度/高度的一半（100 / 2 = 50）, 为了对比，我们新增一个同位置的矩形,（在useEffect底部添加)12345678910111213141516const createShape = () =&gt; &#123; const graphics = new Graphics() .beginFill(\"#0f0\") .drawRect(0, 0, 100, 100); const shape = new Shape(graphics); shape.x = 150; shape.y = 150; shape.regX = 50; shape.regY = 50; window.stage.addChild(shape); Tween.to(shape, 2, &#123; rotation: 360, repeat: -1, ease: Power0.easeNone &#125;); &#125;;createShape(); 效果如下： 淡蓝色的为该矩形原本的位置，设置regX/regY后，可知图形确实是绕中心旋转。只是该矩形位置发生了偏移，我们需要调整显示对象的位置，将其位置还原为初始状态并围绕中心旋转。123//将createShape中shape的位置往右下调整shape宽度的一半 shape.x += 50 shape.y += 50 效果如下： 设置任意旋转中心现在我们清楚了，regX/regY会改变显示对象的注册点位置，并使该对象位置发生偏移。那我们可以很简单的利用这一特性和显示对象的x,y属性联合使用达到我们的目的。举个例子：现在我们想让矩形绕其右上顶点旋利用regX/regY ，使其绕右顶点旋转利用x, y将偏移后的对象还原至初始位置代码如下：1234567// 第一步实现，将旋转中心移至右顶点shape.regX = 100shape.regY = 0// 第二步实现，设置x,y将显示对象移回初始位置shape.x += 100shape.y = 0 效果如下： 依靠上面拆分的办法，我们就可以将旋转中心设置为该显示对象上的任意一点啦。（大家会不会因此迷糊 如果旋转中心不在显示对象上该如何处理，下面也做一下说明）。 举个例子：现在我们希望矩形绕【画布的左顶点】旋转。 利用regX/regY将显示对象注册点调整为画布左顶点。 利用x,y将显示对象还原至初始位置 所以 其实和旋转中心在显示对象上是一致的。1234567// 第一步shape.regX = -150shape.regY = -150// 第二步shape.x -= 150 shape.y -= 150 效果如下：（速率调快了，方便看效果） 总结： regX/regY会改变其旋转中心，并伴随显示对象位置偏移（相对于原显示对象而言） 当显示对象存在缩放和旋转时，情况会不会不同呢？ 有缩放的情况 给显示对象设置缩放值1shape.scale = 0.5; 设置中心点：1234567// 第一步实现，设置显示对象注册点偏移至中心点处shape.regX = (width / 2) * scaleshape.regY = (height / 2) * scale // 第二步实现，设置x/y将显示对象偏移到原来的位置，shape.x += (width / 2) * scaleshape.y += (height / 2) * scale 很显然，位置计算并不正确。因为缩放不会影响注册点所在坐标系。调整regX/regY取值12shape.regX = width / 2shape.regY = height / 2 则得到绕中心点旋转结果，效果如下： 有旋转的情况 给显示对象本身设置旋转角度1234567shape.rotation = 30; //处理中心点设置shape.regX = width / 2shape.regY = height / 2shape.x += width / 2shape.y += height / 2 即：显示对象的旋转，不会影响旋转中心的设置 总结： regX/regY、x/y配合使用可以设置任意中心点。另外通过旋转和缩放两种情况中心点的设置和效果可知：缩放在中心点设置之前就已生效所以缩放是以其左顶点进行缩放，而旋转是在设置完中心点之后生效，所以其是绕其中心点进行旋转的。额外需要注意的是，当设完中心点，对象经过旋转动效后，如需要将中心点重置为左顶点时。此时注册点的偏移量重置为0。但x, y的位置需要通过旋转公式求出旋转后左顶点的坐标，而不是单纯的还原位置。","pubDate":"Thu, 05 Nov 2020 07:40:20 GMT","guid":"https://aotu.io/notes/2020/11/05/easeJs-center-setting/","category":"经验分享"},{"title":"node.js 沙盒逃逸分析","link":"https://aotu.io/notes/2020/10/28/node-sandbox-escape-analysis/","description":"背景日常开发需求中有时候为了追求灵活性或降低开发难度，会在业务代码里直接使用 eval/Function/vm 等功能，其中 eval/Function 算是动态执行 JS，但无法屏蔽当前执行环境的上下文，但 node.js 里提供了 vm 模块，相当于一个虚拟机，可以让你在执行代码时候隔离当前的执行环境，避免被恶意代码攻击。 vm 基本介绍vm 模块可在 V8 虚拟机上下文中编译和运行代码，虚拟机上下文可自行配置，利用该特性做到沙盒的效果。例如： 12345678910111213const vm = require(\"vm\");const x = 1;const y = 2;const context = &#123; x: 2, console &#125;;vm.createContext(context); // 上下文隔离化对象。const code = \"console.log(x); console.log(y)\";vm.runInContext(code, context);// 输出 2// Uncaught ReferenceError: y is not defin 根据以上示例，可以看出和 eval/Function 最大的区别就是可自定义上下文，也就可以控制被执行代码的访问资源。例如以上示例，除了语言的语法、内置对象等，无法访问到超出上下文外的任何信息，所以示例中出现了错误提示: y 未定义。以下是 vm 的的执行示例图： 沙盒环境代码只能读取 VM 上下文 数据。 沙盒逃逸node.js 在 vm 的文档页上有如下描述： vm 模块不是安全的机制。 不要使用它来运行不受信任的代码。 刚开始看到这句话的很好奇，为什么会这样？按照刚才的理解他应该是安全的？搜索后我们找到一段逃逸示例： 123456789const vm = require(\"vm\");const ctx = &#123;&#125;;vm.runInNewContext( 'this.constructor.constructor(\"return process\")().exit()', ctx);console.log(\"Never gets executed.\"); 以上示例中 this 指向 ctx 并通过原型链的方式拿到沙盒外的 Funtion，完成逃逸，并执行逃逸后的 JS 代码。 以上示例大致拆分： 12345tmp = ctx.constructor; // Objectexec = tmp.constructor; // Functionexec(\"return Process\"); 以上是通过原型链方式完成逃逸，如果将上下文对象的原型链设置为 null 呢？ 1const ctx = Object.create(null); 这时沙盒在通过 ctx.constructor，就会出错，也就无法完成沙盒逃逸，完整示例如下： 123456789const vm = require(\"vm\");const ctx = Object.create(null);vm.runInNewContext( 'this.constructor.constructor(\"return process\")().exit()', ctx);// throw Error 但，真的这样简单吗？ 再来看看以下成功逃逸示例： 1234567891011const vm = require(\"vm\");const ctx = Object.create(null);ctx.data = &#123;&#125;;vm.runInNewContext( 'this.data.constructor.constructor(\"return process\")().exit()', ctx);// 逃逸成功！console.log(\"Never gets executed.\"); 为什么会这样？ 原因 由于 JS 里所有对象的原型链都会指向 Object.prototype，且 Object.prototype 和 Function 之间是相互指向的，所有对象通过原型链都能拿到 Function，最终完成沙盒逃逸并执行代码。 逃逸后代码可以执行如下代码拿到 require，从而并加载其他模块功能，示例： 1234567891011121314const vm = require(\"vm\");const ctx = &#123; console,&#125;;vm.runInNewContext( ` var exec = this.constructor.constructor; var require = exec('return process.mainModule.constructor._load')(); console.log(require('fs'));`, ctx); 沙盒执行上下文是隔离的，但可通过原型链的方式获取到沙盒外的 Function，从而完成逃逸，拿到全局数据，示例图如下： 总结由于语言的特性，在沙盒环境下通过原型链的方式能获取全局的 Function，并通过它来执行代码。 最终确实如官方所说，在使用 vm 的时应确保所运行的代码是可信任的。 eval/Function/vm 等可动态执行代码的功能在 JavaScript 里一定是用来执行可信任代码。 以下可能是比较常见会用到动态执行脚本的场景：模板引擎，H5 游戏、追求高度灵活配置的场景。 解决方案 事前处理，如：代码安全扫描、语法限制 使用 vm2 模块，它的本质就是通过代理的方式来进行安全校验，虽然也可能还存在未出现的逃逸方式，所以在使用时也谨慎对待。 自己实现解释器，并在解释器层接管所有对象创建及属性访问。","pubDate":"Wed, 28 Oct 2020 07:40:20 GMT","guid":"https://aotu.io/notes/2020/10/28/node-sandbox-escape-analysis/","category":"node.js"},{"title":"从浏览器渲染层面解析css3动效优化原理","link":"https://aotu.io/notes/2020/10/13/css3-optimization/","description":"引言在h5开发中，我们经常会需要实现一些动效来让页面视觉效果更好，谈及动效便不可避免地会想到动效性能优化这个话题: 减少页面DOM操作，可以元素使用CSS实现的动效不多出一行js代码 使用绝对定位脱离让DOM脱离文档流，减少页面的重排(relayout) 使用CSS3 3D属性开启硬件加速 那么，CSS3与动效优化有什么关系呢，本文将从浏览器渲染层面讲述CSS3的动效优化原理 浏览器页面展示过程首页，我们需要了解一下浏览器的页面展示过程: Javascript：主要负责业务交互逻辑。 Style: 根据 CSS 选择器，对每个 DOM 元素匹配对应的 CSS 样式。 Layout: 具体计算 DOM 元素显示在屏幕上的大小及位置。 Paint: 实现一个 DOM 元素的可视效果(颜色、边框、阴影等)，一般来说由多个渲染层完成。 Composite: 当每个层绘制完成后，浏览器会将所有层按照合理顺序合并为一个图层，显示到屏幕。本文我们将重点关注 Composite 过程。 浏览器渲染原理在讨论 Composite 之前，我们还需要了解一下浏览器渲染原理 从该图中，我们可以发现： DOM 元素与 Layout Object 存在一一对应的关系 一般来说，拥有相同坐标空间的 Layout Object 属于同一个 Paint Layer (渲染层)，通过 position、opacity、filter等 CSS 属性可以创建新的 Paint Layer 某些特殊的 Paint Layer 会被认为是 Composite Layer (合成层/复合层)，Composite Layer 拥有单独的 Graphics Layer (图形层)，而那些非 Composite Layer 的 Paint Layer，会与拥有 Graphics Layer 的父层共用一个 Graphics Layer我们日常生活中所看到屏幕可视效果可以理解为：由多个位图通过 GPU 合成渲染到屏幕上，而位图的最小单位是像素。如下图： 那么位图是怎么获得的呢，Graphics Layer 便起到了关键作用,每个 Graphics Layer 都有一个 Graphics Context, 位图是存储在共享内存中，Graphics Context 会负责将位图作为纹理上传到GPU中，再由GPU进行合成渲染。如下图： CSS在浏览器渲染层面承担了怎样的角色大多数人对于CSS3的第一印象，就是可以通过3D(如transform)属性来开启硬件加速，许多同学在重构某一个项目时，考虑到动画性能问题，都会倾向: 将2Dtransform改为3Dtransform2.将 left ( top、bottom、right )的移动改为 3Dtransform但开启硬件加速的底层原理其实就在于将 Paint Layer 提升到了 Composite Layer以下的几种方式都用相同的作用： 3D属性开启硬件加速(3d-transform) will-change: (opacity、transform、top、left、bottom、right) 使用fixed或sticky定位 对opacity、transform、filter应用了 animation(actived) or transition(actived)，注意这里的 animation 及 transition 需要是处于激活状态才行 我们来写两段 demo 代码，带大家具体分析一下实际情况 demo1. 3D属性开启硬件加速(3d-transform) 1234567891011.composited&#123; width: 200px; height: 200px; background: red; transform: translateZ(0)&#125;&lt;/style&gt;&lt;div class=\"composited\"&gt; composited - 3dtransform&lt;/div&gt; 可以看到是因为使用的CSS 3D transform，创建了一个复合层 demo2. 对opacity、transform、filter应用 animation(actived) or transition(actived) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;style&gt;@keyframes move&#123; 0%&#123; top: 0; &#125; 50%&#123; top: 600px; &#125; 100%&#123; top: 0; &#125;&#125;@keyframes opacity&#123; 0%&#123; opacity: 0; &#125; 50%&#123; opacity: 1; &#125; 100%&#123; opacity: 0; &#125;&#125;#composited&#123; width: 200px; height: 200px; background: red; position: absolute; left: 0; top: 0; &#125;.both&#123; animation: move 2s infinite, opacity 2s infinite;&#125;.move&#123; animation: move 2s infinite;&#125;&lt;/style&gt;&lt;div id=\"composited\" class=\"both\"&gt; composited - animation&lt;/div&gt;&lt;script&gt;setTimeout(function()&#123; const dom = document.getElementById('composited') dom.className = 'move'&#125;,5000)&lt;/script&gt; 这里我们定义了两个keyframes(move、opacity)，还有两个class(both、move)，起初 #composited 的 className = &#39;both&#39;，5秒延时器后，className = &#39;move&#39;，我们来看看浏览器的实际变化。 起初：#composited 创建了一个复合层，并且运动时 fps 没有波动，性能很稳定 5秒后：复合层消失，运动时 fps 会发生抖动，性能开始变得不再稳定 如何查看复合层及fps在浏览器的 Dev Tools 中选择 More tools，并勾选 Rendering 中的 FPS meter 动画性能最优化之前，我们提到了页面呈现出来所经历的渲染流水线，其实从性能方面考虑，最理想的渲染流水线是没有布局和绘制环节的，为了实现上述效果，就需要只使用那些仅触发 Composite 的属性。目前，只有两个属性是满足这个条件的：transforms 和 opacity（仅部分浏览器支持）。相关信息可查看：css Triggers 总结提升为合成层简单说来有以下几点好处： 合成层的位图，会交由 GPU 合成，比 CPU 处理要快 当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层 对于 transform 和 opacity 效果，部分浏览器不会触发 Layout 和 Paint， 相关信息可查看：css Triggers 缺点： 创建一个新的合成层并不是免费的，它得消耗额外的内存和管理资源。 纹理上传后会交由 GPU 处理，因此我们还需要考虑 CPU 和 GPU 之间的带宽问题、以及有多大内存供 GPU 处理这些纹理的问题 大多数人都很喜欢使用3D属性 translateZ(0) 来进行所谓的硬件加速，以提升性能。但我们还需要切实的去分析页面的实际性能表现，不断的改进测试，这样才是正确的性能优化途径。 参考资料无线性能优化：Composite - 淘系前端团队","pubDate":"Tue, 13 Oct 2020 13:00:00 GMT","guid":"https://aotu.io/notes/2020/10/13/css3-optimization/","category":"经验分享"},{"title":"Flutter 性能优化：图片占位符、预缓存和禁用导航过渡动画","link":"https://aotu.io/notes/2020/10/13/improving-perceived-performance-with-image-placeholders-precaching-and-disabled-navigation/","description":"本文是 Flutter 性能优化系列文章之一，记录了 Flutter 团队优化 Flutter Gallery（https://gallery.flutter.dev/#/） 的实践。本文主要介绍了如何利用图片占位符、预缓存和禁用导航过渡动画提高用户感知性能。原文链接：https://medium.com/flutter/improving-perceived-performance-with-image-placeholders-precaching-and-disabled-navigation-6b3601087a2b 感知性能是指用户感觉 app 有多快（译者注：感性性能是用户视角，而不是指标）。这篇文章介绍了三个提高感知性能的策略：图片占位符、图片预缓存和禁用导航过渡动画。 利用图片占位符防止布局跳动用户等待图片加载，在图片最终显示出来时，布局可能会跳来跳去。通过在布局中使用图片占位符，你可以避免这种跳动，来确保更好的用户体验。 以下这个 GIF 图展示了没有图片占位符时布局的跳动： 在 DartPad 中查看完整例子 如果你的 app 中已经缓存了一个图片占位符，你可以使用 FadeInImage widget 来显示占位符。如果你想使用一个 widget 而不是图片作为占位符，你可以使用 Image.frameBuilder 属性。 Image.frameBuilder 属性负责构建一个图片 widget ，它有四个参数： context：构建上下文 child： widget 子元素 frame：一个代码该 frame 的数字，如果图片还在加载中的话，为 null wasSynchronousLoaded ：布尔值，图片加载完成后为 true 实现占位符 widget 时，首先要通过 wasSynchronousLoaded 检查图片是否已经加载完成，如果加载完成，返回 child 。如果没有，使用 AnimatedSwitcher widget 来创建一个占位符到显示图片的渐现动画： 123456789101112131415161718192021222324252627class ImageWidgetPlaceholder extends StatelessWidget &#123; const ImageWidgetPlaceholder(&#123; Key key, this.image, this.placeholder, &#125;) : super(key: key); final ImageProvider image; final Widget placeholder; @override Widget build(BuildContext context) &#123; return Image( image: image, frameBuilder: (context, child, frame, wasSynchronousLoaded) &#123; if (wasSynchronousLoaded) &#123; return child; &#125; else &#123; return AnimatedSwitcher( duration: const Duration(milliseconds: 500), child: frame != null ? child : placeholder, ); &#125; &#125;, ); &#125;&#125; 有了占位符，布局再也不会跳来跳去了，而且图片也有了渐现效果： 在 DartPad 中查看完整例子 预缓存图片如果你的 app 在显示图片界面之前有欢迎界面，你可以调用 precacheImage 方法来预缓存图片。 1precacheImage(NetworkImage(url), context); 来看一下效果： 在 DartPad 中查看完整例子 在 Flutter web app 中禁用导航过渡动画导航过渡动画一般在用户切换页面时使用，在移动 app 中，这种方式可以很好地让用户知道知道自己在哪里。但是，在 web 中，很少看到这样的交互。所以为了提高感知性能，你可以禁用页面间的过渡动画。 默认情况下， MaterialApp 会根据不同平台来使用不同的过渡动画（Android 向上滑动，而 iOS 是向右（左）滑动）。为了覆盖这个默认行为，你需要创建自定义的 PageTransitionsTheme 类。你可以使用 kIsWeb 常量来判断 app 是否在 web 中运行。如果是，通过返回 child 来禁用过渡动画： 123456789101112131415161718192021222324import 'package:flutter/foundation.dart';import 'package:flutter/material.dart';class NoTransitionsOnWeb extends PageTransitionsTheme &#123; @override Widget buildTransitions&lt;T&gt;( route, context, animation, secondaryAnimation, child, ) &#123; if (kIsWeb) &#123; return child; &#125; return super.buildTransitions( route, context, animation, secondaryAnimation, child, ); &#125;&#125; 设置 MaterialApp 的 pageTransitionsTheme 选项： 12345MaterialApp( theme: ThemeData( pageTransitionsTheme: NoTransitionsOnWeb(), ),) 没有任何过渡动画的页面切换效果如下： 在 DartPad 中查看完整的交互例子 结语希望你在本文中找到一些有用的技巧来提高 Flutter web app 的感知性能。在 Flutter Gallery 中，我们禁用了 web 端的导航过渡动画和使用了图片占位符来避免加载页面时布局的跳动，其中的实现和本文所描述的是类似，如果你想看代码，可以在 GitHub 上找到。 感谢阅读！ 这篇文章是我们在提高 Flutter Gallery 性能中学习到的系列内容之一。希望对你有所帮助，能让你学到可以在你的 Flutter app 中用上的内容。系列文章如下： Flutter 性能优化系列之 tree shaking 和延迟加载 Flutter 性能优化系列之图片占位符、预缓存和禁用导航过渡动画（本文） Flutter 性能优化系列之打造高性能 widget","pubDate":"Tue, 13 Oct 2020 12:45:00 GMT","guid":"https://aotu.io/notes/2020/10/13/improving-perceived-performance-with-image-placeholders-precaching-and-disabled-navigation/","category":"Flutter"},{"title":"Flutter 性能优化：tree shaking 和延迟加载","link":"https://aotu.io/notes/2020/10/13/optimizing-performance-in-flutter-web-apps-with-tree-shaking-and-deferred-loading/","description":"本文是 Flutter 性能优化系列文章之一，记录了 Flutter 团队优化 Flutter Gallery（https://gallery.flutter.dev/#/） 的实践。本文主要介绍了 tree shaking 和延迟加载在性能优化中的使用。原文链接：https://medium.com/flutter/optimizing-performance-in-flutter-web-apps-with-tree-shaking-and-deferred-loading-535fbe3cd67 在优秀的用户体验中，app 的加载速度扮演着重要角色。Flutter web app 的初次加载时间可以通过最小化 JS 包体积来提高。Dart 编译器自带 tree shaking 和延迟加载特性，这两者都可以最大程度地减少 JS 包体积。这篇文章介绍了这两个特性的工作原理，以及如何应用。 默认开启的 tree shaking 特性编译 Flutter web app 时，JS 包是通过 dart2js 编译器生成的。一次 release 构建将会得到最高级别的优化，其中就包括了 tree shaking。 Tree shaking 是一个通过只将一定会被执行到的代码包含进来，从而剔除无用代码的过程。所以说，你不用担心你的 app 引用的各种库，因为没有用到的 class 或者 function 会被排除掉。 来看一下 tree shaking 的实际效果： 创建一个 Dart 文件 greeter.dart : 123456789101112131415abstract class Greeter &#123; String greet(String name);&#125;class EnglishGreeter implements Greeter &#123; String greet(String name) =&gt; 'Hello $name';&#125;class SwedishGreeter implements Greeter &#123; String greet(String name) =&gt; 'Hej $name';&#125;void main() &#123; print(EnglishGreeter().greet('World'));&#125; 执行 dart2js -04 greeter.dart 命令，然后看一下生成的文件 out.js。 在生成的 JS 代码中，没有 SwedishGreeter 类，也找不到 Hej $name，因为它们在 tree shaking 过程中被编译器移除了。 如果只通过静态分析，编译器只能找出哪些代码是会被执行，哪些不会被执行的。举个例子，假如 greeter 的定义依赖系统地区设置： 123456Locale locale = Localizations.localeOf(context);if (locale.languageCode == 'sv') &#123; greeter = SwedishGreeter();&#125; else &#123; greeter = EnglishGreeter();&#125; 编译器不知道用户的系统地区设置，因此 EnglishGreeter 和 SwedishGreeter 都会被打包进去。对于这种情况，延迟加载可以帮助减少初始化的包体积。 延迟加载延迟加载，也叫懒加载，允许你在需要时再加载各种库。它可以用来加载 app 中很少用到的功能。请注意延迟加载是一个 dart2js 特性，所以这个特性对移动端 Flutter app 不可用。在以下这个最简单的例子中，将包或者文件引入为 deferred，然后在使用时先等待加载： 123456import 'greeter.dart' deferred as greeter;void main() async &#123; await greeter.loadLibrary(); runApp(App(title: greeter.EnglishGreeter().greet('World')));&#125; 在 Flutter 中，一切都是 widget，所以你可能会需要用到 FutureBuilder。因为一个 widget 的构建方法应该是同步的，因此你不能在一个构建方法中去 await loadLibrary 方法。但是，你可以在构建方法中返回一个 FutureBuilder，你也可以在等待加载库时使用它来显示不同的 UI： 123456789101112import 'greeter.dart' deferred as greeter;FutureBuilder( future: greeter.loadLibrary(), builder: (context, snapshot) &#123; if (snapshot.connectionState == ConnectionState.done) &#123; return Text(greeter.greet('World')); &#125; else &#123; return Text('Loading...'); &#125; &#125;,) 你可以尝试运行这个仓库中完整的例子，打开 Chrome 开发者工具，然后点击网络 tab 查看网络活动。刷新页面来观察库是什么时候引入和加载的。在下面的截图中，文件 main.dart.js_1.part.js 的加载是延迟的： Flutter Gallery 中的本地化延迟加载Flutter Gallery 支持超过 70 中语言，但是大多数用户只用到一种。延迟加载本地化字符串是这个特性非常棒的应用。比如，实现了延迟加载本地化字符串之后，app 的初始化 JS 包体积减少了一半。如果你的 Flutter web app 中有很多本地化字符串，可以考虑一下延迟加载这些文件。gen_l10n.dart 脚本 使用了 –use-deferred-loading 选项来实现这个需求（目前只在 1.19 SDK master channel 上可用）。 这篇文章是我们在提高 Flutter Gallery 性能中学习到的系列内容之一。希望对你有所帮助，能让你学到可以在你的 Flutter app 中用上的内容。系列文章如下： Flutter 性能优化系列之 tree shaking 和延迟加载（本文） Flutter 性能优化系列之图片占位符、预缓存和禁用导航过渡动画 Flutter 性能优化系列之打造高性能 widget","pubDate":"Tue, 13 Oct 2020 12:45:00 GMT","guid":"https://aotu.io/notes/2020/10/13/optimizing-performance-in-flutter-web-apps-with-tree-shaking-and-deferred-loading/","category":"Flutter"},{"title":"Flutter 性能优化：打造高性能 widget","link":"https://aotu.io/notes/2020/10/13/build-performant-flutter-widget/","description":"本文是 Flutter 性能优化系列文章之一，记录了 Flutter 团队优化 Flutter Gallery（https://gallery.flutter.dev/#/） 的实践。本文主要介绍了如何打造高性能的 widget。原文链接：https://medium.com/flutter/building-performant-flutter-widgets-3b2558aa08fa 所有无状态和有状态 widget 都会实现 build() 方法，这个方法决定了它们是如何渲染的。app 中的一屏就可能有成百上千个部件，这些部件可能只会构建一次，或者在有动画或者某种特定的交互情况下，也有可能构建多次。如果想构建快速的 widget，你一定要很谨慎地选择构建哪些 widget，以及在什么时候构建。 这篇文章主要讨论只构建必要的和只在必要时构建，然后会分享我们是如何使用这个办法来显著提高 Flutter Gallery 的性能。我们还会分享一些高级技巧用于诊断你的 web app 中类似的问题。 只在必要时构建一个重要的优化方法是，只在绝对必要时才构建 widget。 谨慎地调用 setState()调用 setState 方法会引起 build() 方法调用。如果调用太多次，会使性能变慢。 看一下下面的动画，显示在前面的黑色 widget 向下滑动，露出后面类似棋盘的面板，类似于 bottom sheet 的行为。前面黑色 widget 很简单，但是后面的 widget 很忙碌。 123456789101112Stack( children: [ Back(), PositionedTransition( rect: RelativeRectTween( begin: RelativeRect.fromLTRB(0, 0, 0, 0), end: RelativeRect.fromLTRB(0, MediaQuery.of(context).size.height, 0, 0), ).animate(_animationController), child: Front(), ) ], ), 你可能会像以下这样写父 widget，但在这个场景下，这样是错误的： 1234567891011121314// BAD CODE@overridevoid initState() &#123; super.initState(); _animationController = AnimationController( duration: Duration(seconds: 3), vsync: this, ); _animationController.addListener(() &#123; setState(() &#123; // Rebuild when animation ticks &#125;); &#125;);&#125; 这样性能并不好。为什么？因为动画在做不必要的工作。 以下是有问题的代码： 123456// BAD CODE_animationController.addListener(() &#123; setState(() &#123; // Rebuild when animation ticks. &#125;);&#125;); 这种类型的动画只在你需要让整个 widget 动起来时才推荐使用，但这并不是我们在这种布局中需要的。 在动画监听器中调用 setState() 会引起整个 Stack 重新构建，这是完全没必要的 PositionedTransition 部件已经一个 AnimatedWidget 了，所以它会在动画开始的时候自动重新构建 不需要在这里调用 setState() 即使后面的组件是很忙碌的，前面的组件动画也可以达到 60 FPS。更多有关合理地调用 setState 方法的内容，请看 Flutter 卡顿的动画：你不该这样 setState 只构建必要的部分除了只在必要的时候进行构建，你还需要只构建 UI 中变化的部分。接下来的章节主要关注如何创建一个高性能的 list。 优先使用 ListView.builder()首先，让我们简单地看看显示 list 的基础： 竖 list 使用 Column 如果 list 需要滚动，使用 ListView 如果 list 有很多 item，使用 ListView.builder，这个方法会在 item 滚动进入屏幕的时候才创建 item，而不是一次性创建所有的 item。这在 list 很复杂和 widget 嵌套很深的情况下，有明显的性能优势。 为了解释多 item 情况下 ListView.builder 相较于 ListView 的优势，我们来看几个例子。 在这个 DartPad 例子中运行以下 ListView。你可以看到 8 个 item 都创建好了。（点击左下角的 Console 按钮，然后点击Run按钮。右边的输出面板没有滚动条，但是你可以滚动内容，然后通过控制台看到什么被创建了以及什么时候进行构建） 123456789101112ListView( children: [ _ListItem(index: 0), _ListItem(index: 1), _ListItem(index: 2), _ListItem(index: 3), _ListItem(index: 4), _ListItem(index: 5), _ListItem(index: 6), _ListItem(index: 7), ],); 接下来，在这个 DartPad 例子中运行 ListView.builder。你可以看只有可见的 item 被创建了，当你滚动时，新的 item 才被创建。 123456ListView.builder( itemBuilder: (context, index) &#123; return _ListItem(index: index); &#125;, itemCount: 8,); 现在，运行这个例子。在这里例子中，ListView的孩子都是提前一次性创建好的。在这种场景下，使用 ListView 的效率更高。 1234567891011121314151617181920final listItems = [ _ListItem(index: 0), _ListItem(index: 1), _ListItem(index: 2), _ListItem(index: 3), _ListItem(index: 4), _ListItem(index: 5), _ListItem(index: 6), _ListItem(index: 7),];@overrideWidget build(BuildContext context) &#123; // 这种情况下 ListView.builder 并不会有性能上的好处 return ListView.builder( itemBuilder: (context, index) &#123; return listItems[index]; &#125;, itemCount: 8, );&#125; 更多有关延迟构建 list 的内容，请看 Slivers, Demystified。 怎样通过一行代码，提升超过两倍的性能Flutter Gallery 支持超过 100 个地区；这些地区，可能你也猜到了，是通过 ListView.builder() 来展示的。通过查看 widget 重新构建的次数，我们注意到这些 item 会在启动时进行不必要的构建。这个情况有点难发现，因为这些 item 藏在折叠了两层的菜单下：设置面板和地区列表。（后来我们发现，因为使用了 ScaleTransitioin ，设置面板在不可见状态下也会进行渲染，意味着它会不断地被构建）。 通过简单地将 ListView.builder 的 itemCount 在未展开状态下设置为 0，我们确保了 item 只会在展开的、可见的设置面板中才进行构建。这一行改动提高了在 web 环境下渲染时间将近两倍，其中的关键是定位过度的 widget 构建。 如何查看 widget 的构建次数虽然 Flutter 的构建是很高效的，但是也会出现过度构建导致性能问题的情况。有几种方法可以帮助定位过度的 widget 构建： 使用 Android Studio/IntelliJAndroid Studio 和 IntelliJ 开发者可以使用自带的工具来查看 widget 重新构建信息。 修改 Flutter 框架本身如果使用的不是以上的编辑器，或者希望可以知道 web 环境下 widget 的重新构建次数，你可以在 Flutter 框架中加入几行简单的代码。 先看一下输出效果： 1234RaisedButton 1RawMaterialButton 2ExpensiveWidget 538Header 5 先定位到文件：&lt;Flutter path&gt;/packages/flutter/lib/src/widgets/framework.dart ，然后加入以下代码。这些代码会在启动时统计 widget 的构建次数，并在一段时间（这里设置的是 10 秒）后输出结果。 123456789101112131415161718192021222324252627bool _outputScheduled = false;Map&lt;String, int&gt; _outputMap = &lt;String, int&gt;&#123;&#125;;void _output(Widget widget) &#123; final String typeName = widget.runtimeType.toString(); if (_outputMap.containsKey(typeName)) &#123; _outputMap[typeName] = _outputMap[typeName] + 1; &#125; else &#123; _outputMap[typeName] = 1; &#125; if (_outputScheduled) &#123; return; &#125; _outputScheduled = true; Timer(const Duration(seconds: 10), () &#123; _outputMap.forEach((String key, int value) &#123; switch (widget.runtimeType.toString()) &#123; // Filter out widgets whose build counts we don't care about case 'InkWell': case 'RawGestureDetector': case 'FocusScope': break; default: print('$key $value'); &#125; &#125;); &#125;);&#125; 然后，修改 StatelessElement 和 StatelessElement 的 build 方法来调用 _output(widget)。 12345678910111213141516class StatelessElement extends ComponentElement &#123; ...@override Widget build() &#123; final Widget w = widget.build(this); _output(w); return w; &#125;class StatefulElement extends ComponentElement &#123;...@override Widget build() &#123; final Widget w = _state.build(this); _output(w); return w; &#125; 你可以在这里查看修改后的 framework.dart 文件。 需要注意的是，几次重新构建不一定会引起问题，但是这个办法可以通过验证不可见的 widget 是否在构建来帮你 debug 性能问题。 web 专用 tips：你可以添加一个 resetOutput 函数（可以在浏览器的控制台中调用）来获取随时获取 widget 的构建次数。 import 'dart:js' as js; void resetOutput() { _outputScheduled = false; _outputMap = &lt;String, int&gt;{}; } void _output(Widget widget) { // Add this line js.context['resetOutput'] = resetOutput; ... 查看修改后的 framework.dart 文件。 结语高效的性能调优需要我们明白底层的工作原理。文章里的 tips 可以帮助你决定什么时候构建 widget 来使你的 app 在所有场景都保持高性能。 这篇文章是我们在提高 Flutter Gallery 性能中学习到的系列内容之一。希望对你有所帮助，能让你学到可以在你的 Flutter app 中用上的内容。系列文章如下： Flutter 性能优化系列之 tree shaking 和延迟加载 Flutter 性能优化系列之图片占位符、预缓存和禁用导航过渡动画 Flutter 性能优化系列之打造高性能 widget（本文） 你还可以查看适用所有水平开发者的 Flutter UI 性能文档。","pubDate":"Tue, 13 Oct 2020 12:00:00 GMT","guid":"https://aotu.io/notes/2020/10/13/build-performant-flutter-widget/","category":"Flutter"},{"title":"你可能不知道的Animation动画技巧与细节","link":"https://aotu.io/notes/2020/10/13/animation-skill/","description":"引言在 web 应用中，前端同学在实现动画效果时往往常用的几种方案： css3 transition / animation - 实现过渡动画 setInterval / setTimeout - 通过设置一个间隔时间来不断的改变图像的位置 requestAnimationFrame - 通过一个回调函数来改变图像位置，由系统来决定这个回调函数的执行时机，比定时修改的性能更好，不存在失帧现象 在大多数需求中，css3 的 transition / animation 都能满足我们的需求，并且相对于 js 实现，可以大大提升我们的开发效率，降低开发成本。 本篇文章将着重对 animation 的使用做个总结，如果你的工作中动画需求较多，相信本篇文章能够让你有所收获： Animation 常用动画属性 Animation 实现不间断播报 Animation 实现回弹效果 Animation 实现直播点赞效果 ❤️ Animation 与 Svg 又会擦出怎样的火花呢？🔥 Loading 组件 进度条组件 Animation steps() 运用 ⏰ 实现打字效果 绘制帧动画 Animation 常用动画属性 介绍完 animation 常用属性，为了将这些属性更好地理解与运用，下面将手把手实现一些 DEMO 具体讲述 Animation 实现不间断播报 实现不间断播报 DEMO 通过修改内容在父元素中的 y 轴的位置来实现广播效果 12345678910111213141516@keyframes scroll &#123; 0%&#123; transform: translate(0, 0); &#125; 100%&#123; transform: translate(0, -$height); &#125;&#125;.ul &#123; animation-name: scroll; animation-duration: 5s; animation-timing-function: linear; animation-iteration-count: infinite; /* animation: scroll 5s linear infinite; 动画属性简写 */&#125; 此处为了保存广播滚动效果的连贯性，防止滚动到最后一帧时没有内容，需要多添加一条重复数据进行填充 12345678&lt;div class=\"ul\"&gt; &lt;div class=\"li\"&gt;小刘同学加入了凹凸实验室&lt;/div&gt; &lt;div class=\"li\"&gt;小邓同学加入了凹凸实验室&lt;/div&gt; &lt;div class=\"li\"&gt;小李同学加入了凹凸实验室&lt;/div&gt; &lt;div class=\"li\"&gt;小王同学加入了凹凸实验室&lt;/div&gt; &lt;!-- 插入用于填充的数据数据 --&gt; &lt;div class=\"li\"&gt;小刘同学加入了凹凸实验室&lt;/div&gt;&lt;/div&gt; Animation 实现回弹效果通过将过渡动画拆分为多个阶段，每个阶段的 top 属性停留在不同的位置来实现 实现回弹效果 DEMO 1234567891011121314151617181920212223/* 规定动画，改变top,opacity */@keyframes animate &#123; 0% &#123; top: -100%; opacity: 0; &#125; 25% &#123; top: 60; opacity: 1; &#125; 50% &#123; top: 48%; opacity: 1; &#125; 75% &#123; top: 52%; opacity: 1; &#125; 100%&#123; top: 50%; opacity: 1; &#125;&#125; 为了让过渡效果更自然，这里通过 cubic-bezier() 函数定义一个贝塞尔曲线来控制动画播放速度 过渡动画执行完后，为了将让元素应用动画最后一帧的属性值，我们需要使用 animation-fill-mode: forwards 12345678.popup &#123; animation-name: animate; animation-duration: 0.5s; animation-timing-function: cubic-bezier(0.21, 0.85, 1, 1); animation-iteration-count: 1; animation-fill-mode: forwards; /* animation: animate 0.5s cubic-bezier(0.21, 0.85, 1, 1) 1 forwards; 动画属性简写 */&#125; Animation 实现点赞效果 Online Code 实现点赞效果 DEMO 相信大多数同学都知道点赞效果，本文章会实现一个简易版的点赞效果，主要讲述一下实现思路： 为了让气泡可以向上偏移，我们需要先实现一个 y 轴方向上移动的 @keyframes 动画 123456789101112/* 规定动画，改变y轴偏移距离*/@keyframes animation-y &#123; 0%&#123; transform: translate(-50%, 100px) scale(0); &#125; 50%&#123; transform: translate(-50%, -100px) scale(1.5); &#125; 100%&#123; transform: translate(-50%, -300px) scale(1.5); &#125;&#125; 为了让气泡向上偏移时显得不太单调，我们可以再实现一个 x 轴方向上移动的 @keyframes 动画 123456789101112131415/* 规定动画，改变x轴偏移距离 */@keyframes animation-x &#123; 0%&#123; margin-left: 0px; &#125; 25%&#123; margin-left: 25px; &#125; 75%&#123; margin-left: -25px; &#125; 100%&#123; margin-left: 0px; &#125;&#125; 这里我理解： 虽然是修改 margin 来改变 x 轴偏移距离，但实际上与修改 transform没有太大的性能差异 因为通过 @keyframes animation-y 中的 transform 已经新建了一个渲染层 ( PaintLayers ) animation 属性 可以让该渲染层提升至 合成层(Compositing Layers) 拥有单独的图形层 ( GraphicsLayer )，即开启了硬件加速 ，不会影响其他渲染层的 paint、layout 对于合成层(Compositing Layers)相关知识不是很了解的同学，可以阅读一下这篇文章从浏览器渲染层面解析 css3 动效优化原理 如下图所示： 如笔者这里理解有误，还请读者大佬指出，感激不尽~ 给气泡应用上我们所实现的两个 @keyframes 动画 1234.bubble &#123; animation: animation-x 3s -2s linear infinite,animation-y 4s 0s linear 1;/* 给 bubble 开启了硬件加速 */&#125; 在点赞事件中，通过 js 操作动态添加/移除气泡元素 12345678function like() &#123; const likeDom = document.createElement('div'); likeDom.className = 'bubble'; // 添加样式 document.body.appendChild(likeDom); // 添加元素 setTimeout( () =&gt; &#123; document.body.removeChild(likeDom); // 移除元素 &#125;, 4000)&#125; Animation 与 Svg 绘制 loading/进度条 组件 🔥 Online Code Animation 与 Svg 绘制 loading/进度条 组件 🔥 DEMO 首先，我们使用 svg 绘制一个圆周长为2 * 25 * PI = 157 的圆 123&lt;svg with='200' height='200' viewBox=\"0 0 100 100\" &gt; &lt;circle cx=\"50\" cy=\"50\" r=\"25\" fill=\"transparent\" stroke-width=\"4\" stroke=\"#0079f5\" &gt;&lt;/circie&gt;&lt;/svg&gt; 将实线圆绘制成虚线圆，这里需要用 stoke-dasharray:50, 50 (可简写为50) 属性来绘制虚线, stoke-dasharray 参考资料 它的值是一个数列，数与数之间用逗号或者空白隔开，指定短划线(50px)和缺口(50px)的长度。 由于50(短划线) + 50(缺口) + 50(段划线) = 150, 150 &lt; 157，无法绘制出完整的圆，所以会导致右边存在缺口(7px) 123&lt;svg with='200' height='200' viewBox=\"0 0 100 100\" &gt; &lt;circle cx=\"50\" cy=\"50\" r=\"25\" fill=\"transparent\" stroke-width=\"4\" stroke-dasharray=\"50\" stroke=\"#0079f5\" &gt;&lt;/circie&gt;&lt;/svg&gt; stroke-dashoffset 属性可以使圆的短划线和缺口产生偏移，添加 @keyframes 动画后能够实现从无到有的效果，stoke-dashoffset 参考资料 设置 stroke-dasharray=&quot;157 157“,指定 短划线(157px) 和 缺口(157px) 的长度。 添加 @keyframes 动画 修改stroke-dashoffset值, 值为正数时逆时针偏移🔄,， 值为负数时，顺时针偏移🔃 1234567891011@keyframes loading &#123; 0%&#123; stroke-dashoffset: 0; &#125; 100%&#123; stroke-dashoffset: -157; /* 线条顺时针偏移 */ &#125;&#125;circle&#123; animation: loading 1s 0s ease-out infinite;&#125; 修改短划线和缺口值 为了让 loading 组件线条可见，我们需要一个50px的短划线,设置 stroke-dasharray=&quot;50&quot; 为了让短划线发生偏移后可以完全消失，缺口需要大于或等于圆周长157，设置 stroke-dasharray=&quot;50 157&quot; 添加 @keyframes 动画,为了让动画结束时仍处理动画开始位置，需要修改 stroke-dashoffset:-207(短划线+缺口长度) 进度条也是类似原理，帮助理解 stroke-dashoffset 属性，具体实现请查看示例 1234567891011@keyframes loading &#123; 0%&#123; stroke-dashoffset: 0; &#125; 100%&#123; stroke-dashoffset: -207; /* 保证动画结束时仍处理动画开始位置 */ &#125;&#125;circle&#123; animation: loading 1s 0s ease-out infinite;&#125; Animation steps()运用steps() 是 animation-timing-function 的属性值 1animation-timing-function : steps(number[, end | start]) steps 函数指定了一个阶跃函数，它接受两个参数 第一个参数接受一个整数值，表示两个关键帧之间分几步完成 第二个参数有两个值 start or end。默认值为 end step-start 等同于 step(1, start)。step-end 等同于 step(1, end) steps 适用于关键帧动画，第一个参数将两个关键帧细分为N帧，第二个参数决定从一帧到另一帧的中间间隔是用开始帧还是结束帧来进行填充。 看下图可以发现: steps(N, start)将动画分为N段，动画在每一段的起点发生阶跃(即图中的空心圆 → 实心圆),动画结束时停留在了第 N 帧 steps(N, end)将动画分为N段，动画在每一段的终点发生阶跃(即图中的空心圆 → 实心圆),动画结束时第 N 帧已经被跳过(即图中的空心圆 → 实心圆)，停留在了 N+1 帧。 实践出真知！Animation 实现打字效果 Animation 实现打字效果 DEMO 此处用英文字母(I’m an O2man.)举例，一共有13个字符。[经测试，多数中文字体每个字符宽高都相等] steps(13)可以将 @keyframes 动画分为13阶段运行,且每一阶段运行距离相等。 效果如下： 12345678910111213/* 改变容器宽度 */@keyframes animate-x &#123; 0%&#123; width: 0; &#125;&#125;p &#123; width: 125px; overflow: hidden; border-right: 1px solid transparent; animation: animate-x 3s 0s steps(13) 1 forwards;&#125; 可以发现仅仅这样还不够，动画运行过程中出现了字符被截断的情况,为了保证每个阶段运行后能准确无误地显示当前所处阶段的字符，我们还需要保证每个字符的width与动画每一阶段运行的距离相等 设置Monaco字体属性，用以保证每个字符的 width 相同，具体像素受fontSize属性影响，示例中的字体宽度约为 9.6px，9.6px * 13(段数) = 124.8px (125px)，所以当我们设置容器宽度为 125px，即可的达成目的：每个字符的 width 与动画每一阶段运行的距离相等(约为 9.6px )。 1234567891011p &#123; /* 设置 Monaco 字体属性，字体大小为16px，用以保证每个字符的 width 相同，width 约为9.6p */ font-family: Monaco; /* 9.6px * 13 = 124.8px (125px) */ width: 125px ; font-size: 16px; overflow: hidden; border-right: 1px solid transparent; /* 同时应用动画 animate-x、cursor-x */ animation: animate-x 3s 0s steps(13) 1 forwards,cursor-x 0.4s 0s linear infinite;&#125; Animation 实现帧动画 ⏰ Animation 实现帧动画 ⏰ DEMO 这里我们拿到了一张47帧的雪碧图（css spirit）,设置背景图 1234567.main &#123; width: 260px; height: 200px; background: url(url) no-repeat; background-size: 100%; background-position: 0 0;&#125; 添加 @keyframes 修改 background-position，让背景图移动 1234567891011121314151617@keyframes animate &#123; 0% &#123; background-position: 0 0; &#125; 100% &#123; background-position: 0 100%; &#125;&#125;.main&#123; width: 260px; height: 200px; background: url(url) no-repeat; background-size: 100%; background-position: 0 0; animation: animate 2s 1s steps(47) infinite alternate;&#125; 同时, css 还提供了animation-play-state用于控制动画是否暂停 123input:checked+.main&#123; animation-play-state: paused;&#125; 文章篇幅较长，感谢大家的阅读，希望各位看客能够有所收获~ ~ ~ 参考资料Animation 常用动画属性CSS 参考手册steps() 参考资料SVG 学习之 stroke-dasharray 和 stroke-dashoffset 详解理解 CSS3 Animation 中的 steps()【译】css 动画里的 steps()用法详解CSS Will Change","pubDate":"Tue, 13 Oct 2020 12:00:00 GMT","guid":"https://aotu.io/notes/2020/10/13/animation-skill/","category":"经验分享"},{"title":"使用 Vue3 开发小程序","link":"https://aotu.io/notes/2020/09/28/taro-vue3/","description":"前言9 月 19 日凌晨，Vue3 在经过多个开发版本的迭代后，终于迎来了它的正式版本，”One Piece” 的代号也昭示了其开拓伟大航路的野心。 Vue3 的新特性主要有 Composition API、Teleport、Fragments 和 &lt;script setup /&gt; &amp; &lt;style vars /&gt; 等。我们是否也可以在小程序开发中使用这些特性呢？在 Taro 的文档里我们找到了关于 Vue3 的章节，事不宜迟，让我们开始尝试吧。 Vue3 部分新特性还没了解过 Vue3 的同学也别急，先了解下 Vue3 的新特性吧： 1.Composition APIVue2.X 基于 Option API（选项 API）构建组件，一般来说组件拥有 data、methods、computed 等选项。这是一种属性相互隔离的模式，好处是各属性内容分离开，对于新手来说比较友好；但对于大型项目来说，为了修改某个功能，可能需要在一个文件中来回翻页。Vue3 增加了 Composition API 方式（组合 API ），基于 reactivity（响应式）的思想进行组件构建，将逻辑封装到函数中，可以实现类似 ReactHooks 的逻辑组合和重用。对于大型项目，代码按照具体功能划分，而不是分散在不同的生命周期中，逻辑更加一目了然。 2.Teleport（传入）Teleport 功能，使得我们可以将全屏的组件（例如 Toast）移到 Vue APP 节点外，而不需要在 UI 界面上修改其他组件样式，方便实现全屏蒙层、浮层弹窗等效果。 3.Fragments（碎片）Vue2.x 版本中，&lt;template /&gt; 标签下不支持放置多个组件，这个限制在 Vue3 中不再存在。这点比较好理解，下述组件设计在 Vue3 中是没有问题的： 123456&lt;!-- Layout.vue --&gt;&lt;template&gt; &lt;header&gt;...&lt;/header&gt; &lt;main v-bind=\"$attrs\"&gt;...&lt;/main&gt; &lt;footer&gt;...&lt;/footer&gt;&lt;/template&gt; 4.实验性质的语法糖 &lt;script setup&gt;、&lt;style vars&gt;a.&lt;script setup&gt;:用于在 SFC 中使用 Composition API 的语法糖，改善在单个文件组件中使用 Composition API 时的体验。 b.&lt;style vars&gt;: SFC 中状态驱动的 CSS 变量，它提供了直接的 CSS 配置和封装，支持将组件状态驱动的 CSS 变量注入到“单个文件组件”样式中。 除了以上 4 点之外，Vue3 还提供了自定义渲染，详细可以参考文末的推荐阅读文章。 如何在 Taro 里使用 Vue3Vue3 带来的新特性可以让我们更加优雅和高效地进行开发，现在，来开启我们在 Taro 里使用 Vue3 的体验之旅吧。 Taro 已经默认安装 Taro3 ，所以正常安装即可： 123456# 使用 npm 安装 CLI$ npm install -g @tarojs/cli# OR 使用 yarn 安装 CLI$ yarn global add @tarojs/cli# OR 安装了 cnpm，使用 cnpm 安装 CLI$ cnpm install -g @tarojs/cli 安装完成之后，使用taro --version查看一下是否安装成功，如果输出版本号说明安装成功。安装成功后，初始化一个项目 1$ taro init 将出现如下图的一些选型 如上图： 请输入项目名称？输入项目名称vuedemo 请输入项目介绍？输入项目介绍a demo project 请选择框架？当然是Vue3啦 余下选项，如上面 3 个选项，根据自己的需要选择就好，不会有什么问题 一般情况下，依照提示选型好以后， Taro 会自动安装依赖。如果由于网络问题导致安装不成功，就需要手动在项目路径下进行安装。 123456# 使用 yarn 安装依赖$ yarn# OR 使用 cnpm 安装依赖$ cnpm install# OR 使用 npm 安装依赖$ npm install 安装后目录结构： app默认代码如下，我们注意到，Taro3 在新建 Vue3 项目时已经修改了入口组件写法。 1234567import &#123; createApp &#125; from 'vue'import './app.scss'const App = createApp(&#123; onShow (options) &#123;&#125;, // 入口组件不需要实现 render 方法，即使实现了也会被 taro 所覆盖&#125;)export default App page/index目录下index文件示例如下： 1234567891011121314151617&lt;template&gt; &lt;view class=\"index\"&gt; &lt;text&gt;&#123;&#123; msg &#125;&#125;&lt;/text&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref &#125; from 'vue'import './index.scss'export default &#123; setup () &#123; const msg = ref('Hello world') return &#123; msg &#125; &#125;&#125;&lt;/script&gt; 编译运行微信小程序 1npm run dev:weapp 编译后，打开微信开发者工具导入编译后的dist目录，首页内容和编译成 H5 的表现都如下图： 验证 Taro3 对 Vue3 的支持度Composition API写个比较简单的 todolist 计数组件，假设目前已有 4 项代办事项，点击后将新增一项。这里会使用到 Composition API 思路，以及 computed 计算属性。 在用户点击时，第二行“当前操作新增”会根据点击次数递增，总计条数会在 4 的基础上累加。 123456789101112131415161718192021222324252627282930313233&lt;template&gt; &lt;button @tap=\"increment\"&gt; 增加 1 &lt;/button&gt; &lt;view&gt;当前todolist事项已有：&#123;&#123; existCount &#125;&#125;条；&lt;/view&gt; &lt;view&gt;当前操作已新增：&#123;&#123; count &#125;&#125; ，共有&#123;&#123; total &#125;&#125;条。&lt;/view&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref, computed, onMounted, toRefs, watch &#125; from 'vue'export default &#123; name: 'case1', setup(props) &#123; // ref响应式变量 const count = ref(0) const existCount = ref(4) // computed方法，在count的value发生改变时，会触发计算total const total = computed(() =&gt; count.value + existCount.value ) function increment() &#123; count.value++ &#125; onMounted(() =&gt; console.log('component mounted!')) return &#123; // 返回increment方法，existCount、count、total属性，供模板中调用 increment, existCount, count, total, &#125; &#125;&#125;&lt;/script&gt; 页面表现如下所示，可见对于 Composition API 的支持的还是不错的。 Teleport写个初次登录用户的欢迎弹窗。用户名从index.vue传入。首页代码如下： 123456&lt;template&gt; &lt;view class=\"index\"&gt; &lt;Toast :user = username /&gt; &lt;view id=\"teleportToast\"&gt;&lt;/view&gt; &lt;/view&gt;&lt;/template&gt; 在 Toast.vue 中，我们会写个属性 to 为 teleportToast 的 Teleport 组件，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;template&gt; &lt;button @tap=\"showToast\" class=\"btn\"&gt;打开弹窗&lt;/button&gt; &lt;!-- to和index.html中的view id一致 --&gt; &lt;teleport to=\"#teleportToast\"&gt; &lt;view v-if=\"toastFlag\" class=\"toast__wrap\" @tap=\"hideToast\"&gt; &lt;view class=\"h2\"&gt;弹窗标题：&lt;/view&gt; &lt;view class=\"toast__wrap--msg\"&gt;欢迎&#123;&#123; user &#125;&#125;，点击关闭&lt;/view&gt; &lt;/view&gt; &lt;/teleport&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref,toRefs &#125; from 'vue';export default &#123; props:&#123; user: &#123;type: String&#125; &#125;, setup(props) &#123; // 获取用户名 const &#123; user &#125; = toRefs(props) // Toast：显示flag const toastFlag = ref(false) let timer const showToast = ()=&gt;&#123; toastFlag.value = true &#125; const hideToast = ()=&gt;&#123; toastFlag.value = false &#125; return &#123; user, toastFlag, showToast, hideToast, &#125; &#125;&#125;&lt;/script&gt;&lt;style lang=\"scss\"&gt;.toast__wrap&#123; position: fixed; width:100%; height: 100%; background: rgba(0,0,0,.8); top: 0; left: 0; z-index: 101; color: #fff; .h2&#123; margin: 20px; &#125; &amp;--msg&#123; text-align: center; &#125;&#125;&lt;/style&gt; 在 H5 下是正常显示的，弹窗展示以及关闭功能效果如下；在小程序上却报错了，Taro 团队还需要加把劲： FragmentsFragments 特性已经在上面的例子中得到验证，使用没有问题。 script setup 语法糖我们尝试一下&lt;script setup&gt;，组件里的代码如下： 12345678910111213141516171819202122&lt;template&gt; &lt;view&gt; &lt;view&gt;count:&#123;&#123; count &#125;&#125;,msg:&#123;&#123; info &#125;&#125;&lt;/view&gt; &lt;button @tap=\"incAndChangeInfo\"&gt; 增加 1修改msg &lt;/button&gt; &lt;/view&gt;&lt;/template&gt;&lt;script setup=\" props \"&gt; import &#123; ref, toRefs &#125; from 'vue' export default&#123; props: &#123; msg: String, &#125;, &#125; export const count = ref(0) export const info = ref(props.msg) export const incAndChangeInfo = () =&gt; &#123; count.value++ info.value = \"change hello\" + count.value &#125;&lt;/script&gt; 上述script标签里的代码效果等同于下面： 123456789101112131415161718192021&lt;script&gt;import &#123; ref, toRefs &#125; from 'vue'export default &#123; props: &#123; msg: String, &#125;, setup(props) &#123; const count = ref(0) const info = ref(props.msg) const incAndChangeInfo = () =&gt; &#123; count.value++ info.value = \"change hello\" + count.value &#125; return &#123; count, info, incAndChangeInfo, &#125; &#125;&#125;&lt;/script&gt; 调用它的代码传入 mgs 如下： 1&lt;Setup msg=\"hello\"/&gt; 运行后，小程序和 H5 都是支持的，页面整体表现如下： 可以看到，运用新特性进行开发，代码书写更加便捷，逻辑更清晰。 style vars 语法糖&lt;style vars&gt;，组件里的代码如下： 123456789101112131415161718192021222324252627&lt;template&gt; &lt;view class=\"text\"&gt;文字颜色为&#123;&#123; color &#125;&#125;,点击后变为红色&lt;/view&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref,toRefs &#125; from 'vue'export default &#123; props:&#123; color: &#123;type: String&#125; &#125;, data(props) &#123; return &#123; color: ref(props) //'red' &#125; &#125;, setup(props)&#123; const &#123; color &#125; = toRefs(props) return &#123; color, &#125; &#125;&#125;&lt;/script&gt;&lt;style vars=\"&#123; color &#125;\"&gt;.text &#123; color: var(--color);&#125;&lt;/style&gt; 调用它的页面里的代码如下： 123456789101112131415161718192021222324&lt;template&gt; &lt;view class=\"index\"&gt; &lt;Styledemo :color = color @tap=\"changeColor\"/&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref, computed, onMounted, toRefs, watch &#125; from 'vue'import Styledemo from \"@/floors/styledemo\"export default &#123; components:&#123; Styledemo &#125;, setup () &#123; const color = ref('blue') const changeColor = ()=&gt;&#123; color.value = 'red' &#125; return &#123; changeColor, color &#125; &#125;&#125;&lt;/script&gt; 小程序和 H5 都没有问题，功能效果如下： 结语我们将上述几个 Demo 整合在一个项目中，放在Github上，有兴趣的同学可以看看。在线预览地址在这里。 经过验证，Taro3 支持使用最新的 Vue3 开发多端应用，相比之下 H5 的支持度更好一些。 值得一提的是，Taro 团队在技术上一直保持进取，在 Taro2.0 版本支持了 ReactHooks；根据Taro RFCS，早在2020-06-03也已经打算支持 Vue3 了。截至目前，Taro 对 Vue3 的支持在小程序端的稍有补足，希望 Taro 团队可以早日补足这个短板。 推荐文章： Vue3 和 React Hooks 对比 SWR 自定义渲染器的应用 参考文章： [1]compsition api [2]teleport [3]taro3安装及使用","pubDate":"Mon, 28 Sep 2020 01:00:00 GMT","guid":"https://aotu.io/notes/2020/09/28/taro-vue3/","category":"小程序"},{"title":"京喜小程序首页无障碍优化实践","link":"https://aotu.io/notes/2020/09/21/jx-weapp-accessible/","description":"前言本文参考 WCAG 2.1 、WAI-ARIA 和 Web 可访问性与无障碍最佳实践，在京喜小程序首页无障碍优化开发中，总结了一些“无障碍优化”在小程序端的实践，希望以此推动无障碍在小程序更多地落地。 无障碍无障碍是什么？在了解无障碍之前，我们先来了解一些数据： 据中国盲协的最新数据显示，中国目前视障者有 1700 多万，随着老龄化的严重，视障群体有进一步扩大的趋势。 在中国，有着庞大的信息障碍群体，包括：8500 多万残障人士，两亿多老年人，大量认知障碍人士。 … 无障碍无障碍 (Accessibility)，是指在发展过程中没有阻碍，活动能够顺利进行。从无障碍引申的相关词汇有，无障碍设施、信息无障碍、无障碍交流等等。 信息无障碍对于信息无障碍，中国互联网协会给出了一个定义：任何人（无论是健全人还是残疾人，无论是年轻人还是老年人）在任何情况下都能平等地、方便地、无障碍地获取信息、利用信息。 以上释义，源自百度百科 无障碍设施如果看不见、听不见，我们该怎么生活呢？ 在生活中，我们常常会看到一些设施：缘石坡道、盲道、无障碍垂直电梯、无障碍扶手、人行横道的警示信号等等。这些给障碍群体使用的安全设施，就是无障碍设施 (Accessibility Facilities)。无障碍设施主要是为了让障碍群体能够自主、安全、方便地通行和活动，它是障碍群体生活顺畅的重要保证。除物质环境的无障碍设施，无障碍设施还可以扩展到信息和交流的无障碍，比如互联网中的网站设计、网上办事、购物交互等。 信息无障碍的现状随着互联网不断发展，互联网应用已经融入到我们生活的各个方面，行动不便的障碍群体则更希望也更需要通过方便的互联网应用获取信息、学习和生活。因此，互联网应用进行无障碍优化，对障碍群体显得尤为重要。 早在 1997 年 2 月，万维网联盟 (W3C) 为了提升网络的无障碍性，成立了网络无障碍推动 (WAI)小组，并制定了一系列的关于网络无障碍的标准、规范、检测表、无障碍的技术，并与世界各地的组织携手合作，在全球范围推动无障碍网络运动。 但至今为止，互联网产品的无障碍优化进展仍然缓慢，很多网站建设和移动端 APP 的开发都还未考虑无障碍优化，即使是通过读屏软件，也很难获取想要的信息。 障碍群体调研 我们以电商平台购物 APP 为调研对象，同信息无障碍研究会合作做了一个调研。根据收集到的舆情反馈，我们了解到： 在消费降级的当下，低价商品火遍互联网的每个角落，障碍群体是其中需求度最大的人群之一。京喜，作为京东旗下的拼购电商平台，与拼多多和淘宝特价版一样，在障碍人士聚集的论坛和QQ中，有非常多的讨论。用户们对京喜没做无障碍表示遗憾，也期待京喜可以尽快开展无障碍优化，享受低价拼购的乐趣。 根据研究会信息无障碍工程师初步检测，目前影响障碍用户们使用缺陷集中在以下几类中： 按钮未加标签，用户难以了解对应按钮点按分别会触发哪些功能。 精简状态不提示或提示不符合障碍用户理解习惯，导致用户无法了解正确的信息，诸如是否已加入购物车等。 焦点逻辑混乱或没有遵循正确的读屏浏览模式，致使用户不能便捷、清晰地了解界面信息，严重影响操作效率。 活动信息或弹窗等页面，由于使用大量字绘架构且没有集成无障碍特性，用户无法便捷地参与平台营销活动。 以上几类属于障碍用户能够无障碍使用的基本支撑，部分或完全适配后将能促使 APP 实现较好的无障碍体验。 无障碍优化开发在了解小程序的无障碍优化之前，首先需要了解 Web 无障碍开发的基础知识，及读屏软件的工作方式。 读屏软件无障碍访问的关键点 —— 使用屏幕阅读器。 移动端 APP 访问无障碍特性，开启读屏模式的设置路径： iOS： 设置 -&gt; 通用 -&gt; 辅助功能 -&gt; 旁白（VoiceOver） 。 安卓：设置 -&gt; 辅助功能 -&gt; 无障碍 -&gt; TalkBack（不同机型路径可能不一样） 以下是一些主要的 VoiceOver 手势： 轻点：选择并朗读项目。 轻点两下：激活所选项目。 左右轻扫：选择下一项或上一项。 三个手指向上或向下轻扫：滑动屏幕上的列表或区。 双指搓擦：快速来回移动两个手指三次（形成“z”字形）以解除提醒，或者返回上一个屏幕。 更多手势可以查看 ：VoiceOver - iPhone 使用手册。 安卓的 TalkBack 手势与 VoiceOver 有一些差异，后面还会提到…… WAI-ARIA WAI-ARIA 通过浏览器把信息暴露给 accessibility APIs (无障碍API)，作为读屏软件的信息源。 WAI-ARIA ( Accessible Rich Internet Applications (WAI-ARIA) 1.1) 是一项技术，它可以通过浏览器和一些辅助技术来帮助我们进一步地识别以及实现语义化，这样一来能帮助我们解决问题，也让用户可以了解发生了什么。WAI-ARIA 是 W3C 编写的规范，定义了一组可用于其他元素的 HTML 特性，用于提供额外的语义化以及改善缺乏的可访问性。 以下是规范中三个主要的特性： 角色 —— 定义元素是干什么的。如 role=&#39;button&#39; 表示元素是按钮，读屏软件会读作“按钮”、role=&#39;searchbox&#39; 表示元素用于搜索，读屏软件会读作”搜索”。 属性 —— 让元素具备更多的意义。如 aria-required=&#39;true&#39; 表示元素在表单上是必填的、aria-label=&#39;描述文字&#39; 用来给当前元素标签加上描述，用不可视的方式给元素加 label，接受字符串作为参数，读屏软件会将描述文字朗读出来。 状态 —— 用于表达元素当前条件的特殊属性。如 aria-disabled=&#39;true&#39;表示表单禁止输入、aria-hidden=&#39;true&#39; 表示元素会被读屏软件忽略。 更多属性可以参考 Using Aria 中的 States and properties，部分属性可能在小程序设置不生效。 更多 role 可以参考 Using Aria 中的 Widget Roles，部分 role 可能在小程序设置不生效。 因此，无障碍优化便可以借助读屏软件，结合 WAI-ARIA 的特性进行开发。互联网应用引入无障碍特性，使得障碍用户可以清晰准确的获取到页面信息，获得更好的产品体验，方便地实现网上办事、购物等。 京喜小程序首页无障碍优化背景此前，京喜小程序未进行无障碍优化，障碍群体在读屏软件的辅助下，基本不能使用。这使得平台失去了障碍群体的市场，同时障碍群体也失去了体验京喜小程序平台服务的机会。因此，希望对平台进行无障碍优化，提升平台的可用性、易用性，让障碍群体享受更好的购物体验。 优化方案产品提供焦点划分规则、朗读规则、阅读顺序，为京喜小程序首页量身定制无障碍优化方案。内部方案，这里就不透露了。（想了解的话，来投一波简历啊~） 开发实现目前小程序官方已经支持无障碍访问特性，用户在读屏模式下可以体验无障碍访问。 开发细则DOM 顺序很重要 读屏软件在读屏时默认按照 DOM 的顺序朗读。如果 DOM 的顺序与内容的语义顺序不一致，会使得内容难以理解。例如首页中的商品瀑布流，按左右两列布局： 在开发过程中应尽量避免使用会影响到 DOM 视觉顺序的样式，如果无法避免，需要手动设置 tabIndex 属性，告知读屏软件正确的内容顺序。 非文本元素增加描述和角色属性 通过给非文本元素增加描述和角色属性，元素的内容就可以被读屏软件清晰准确地朗读。 图像可使用 alt 属性描述图像内容，读屏软件会根据 alt 中的内容朗读出 “描述图像内容 图像”。 view 本身是无语义的，可以给元素增加 aria-role 和 aria-label 属性。 读屏软件会朗读出 “label 描述内容 + role 类型”。 整块元素读取 一个元素可能由很多子元素组成。在无障碍模式下，读屏软件只能分别聚焦子元素，单独将每个子元素信息读出来。障碍用户在读屏软件的辅助下，获取到的都是元素零零碎碎的信息，这样的体验很不友好。 因此，在无障碍优化过程中，可以将元素当作按钮整块朗读，将子元素的信息整合作为描述，并尽量精简描述内容，缩短朗读文案的时间。 隐藏元素读取 如果不希望部分内容被读出来，可以使用 aria-hidden=’true’ 来声明，这样读屏时就会忽略这些元素。 1&lt;Text aria-hidden='true'&gt;读屏时会忽略这行文本&lt;/Text&gt; 在无障碍模式下，这个属性可用来隐藏辅助作用不大或是具有干扰性的内容。 场景实现非文本元素读取 首页头部中京喜 Logo 和文字是一整张图片。聚焦后，读屏软件默认会读成图像，无法将图片中的文字朗读出来。这样的无障碍体验是非常差的。 在这个场景下，可通过给 Logo 图片增加描述来进行无障碍优化。 1234&lt;View className='index__main'&gt; &lt;View className='index__logo' aria-role='text' aria-label='京喜' /&gt; &lt;View className='index__title'&gt;京东旗下社交电商平台&lt;/View&gt;&lt;/View&gt; 类似的还有关闭按钮、返回顶部按钮、菜单栏按钮…… 12345&lt;View className='back-top' aria-role='button' aria-label='返回顶部'/&gt; 搜索框读取 首页搜索框聚焦后，读屏软件默认会将搜索框中的暗纹读出来。但是障碍用户并不能明显的感知到搜索框元素。 在这个场景下，可以通过给搜索框增加角色属性来进行无障碍优化。 123&lt;View aria-role='searchbox'&gt; &lt;SearchBar /&gt;&lt;/View&gt; 轮播图读取 轮播图由多个子元素组成，但点击为整块点击，且每个子元素都是图片，读屏软件无法让用户清晰感知元素的含义。 在这样的场景下，可以给每一个子元素标签增加描述，读屏软件就可以识别到子元素了。 12345678&lt;View className='banner'&gt; &lt;Swiper&gt; &lt;SwiperItem aria-role='text' aria-label='活动推荐1'&gt;活动1&lt;/SwiperItem&gt; &lt;SwiperItem aria-role='text' aria-label='活动推荐2'&gt;活动2&lt;/SwiperItem&gt; &lt;SwiperItem aria-role='text' aria-label='活动推荐3'&gt;活动3&lt;/SwiperItem&gt; &lt;SwiperItem aria-role='text' aria-label='活动推荐4'&gt;活动4&lt;/SwiperItem&gt; &lt;/Swiper&gt;&lt;/View&gt; 但这样的无障碍优化在安卓手机上体验并不友好。 当障碍用户聚焦到轮播图后，读屏软件将子元素的描述朗读读来。轮播图继续轮播，焦点索引却不会随轮播状态自动更新，而是跟随当前子元素滑动消失在屏幕中。若要获取更新后的轮播信息，需要重新聚焦。 在这样的场景下，建议在轮播图的最外层增加描述，将整块内容当作按钮处理，让障碍用户清楚这是整体点击的按钮。 12345678&lt;View className='banner' aria-role='button' aria-label='活动推荐，共4个'&gt; &lt;Swiper&gt; &lt;SwiperItem&gt;活动1&lt;/SwiperItem&gt; &lt;SwiperItem&gt;活动2&lt;/SwiperItem&gt; &lt;SwiperItem&gt;活动3&lt;/SwiperItem&gt; &lt;SwiperItem&gt;活动4&lt;/SwiperItem&gt; &lt;/Swiper&gt;&lt;/View&gt; 商品卡片读取 商品卡片由多个子元素组成，读屏软件会将聚焦的子元素（商品图、名字、价格、利益点等）一个个的读出来。 但单独读出每个子元素，不便于障碍用户理解商品卡片的完整含义。 类似这样的场景，可以将商品卡片当作一个按钮整块处理。在商品卡片最外层标签加上 aria-role=&#39;button&#39;，还可以通过 aria-label 标签，将商品信息进行整合，精简描述，缩短商品名字的朗读时间，让障碍用户获得更好的体验。 隐藏元素读取 上文提到商品卡片的无障碍优化可通过 aria-role=&#39;button&#39; 和 aria-label 来实现。理想情况下，当障碍用户聚焦到商品卡片，读屏软件将整合的商品信息朗读出来，并提示是按钮类型。 但实际情况并非如此。当障碍用户在安卓手机上聚焦后，读屏软件不仅会将整合的商品信息和 role 朗读出来，还会将商品卡片子元素的文本内容朗读出来。（后文会提到 iOS 的表现） 为了避免商品信息重复朗读，可以在元素文本标签上加上 aria-hidden=&#39;true&#39; ，隐藏子元素文本描述，让障碍用户能够获取到清晰简洁的商品信息。 123456&lt;View aria-role='button' aria-label='商品整合信息'&gt; &lt;View aria-hidden='true'&gt; &lt;Image className='goods__img' src='https://img20.360buyimg.com/ling/jfs/t1/129045/25/12798/233574/5f61ffdbE248117d0/52fd1d1ee42b4443.png' lazyLoad /&gt; &lt;View className='goods__info'&gt;商品信息…&lt;/View&gt; &lt;/View&gt;&lt;/View&gt; iOS 和安卓端的差异滑屏手势差异 安卓：双指滑动，根据手势自适应滑动； iOS：三指滑动，一屏一屏分页滑动。 轮播图焦点差异 安卓：焦点位置会跟随子元素滑动消失； iOS：焦点位置固定不变，不会随子元素滑动而消失。 价格读取差异 由于整数部分和小数部分字体大小不同，价格文本是用多个标签实现的。 12345&lt;View&gt; &amp;yen; &lt;Text&gt;259&lt;/Text&gt; &lt;Text&gt;.2&lt;/Text&gt;&lt;/View&gt; 安卓：完整朗读 “259.2元”； iOS：单独朗读单位、整数、小数，并且会将 “￥” 读作“美元符号”。 aria-role=’button’ 读取差异 安卓：读作“描述+按钮+子元素文本描述”，需借助 aria-hidden=&#39;true&#39; 隐藏子元素文本描述，避免信息重复朗读。 iOS：有两种情况。 如果标签同时设置了 aria-label ，则读作“描述 按钮”，不重复朗读子元素文本。 如果标签仅设置了 aria-role=&#39;button&#39; ，会继续识别子元素文本，读作“描述+按钮+子元素文本描述”。为避免重复朗读，也需要给子元素加上 aria-hidden=&#39;true&#39;。 小程序无障碍展望小程序基础库自 2.7.1 起，支持部分 ARIA 标签，但是仍有部分属性和 role 在小程序中不生效，希望未来可以支持所有的 ARIA 标签，给障碍用户带来更好的体验。 另外，小程序目前还没有相关 API 支持识别用户手机是否开启无障碍（读屏）模式（原生 APP 可以通过相关 API识别）。如果能预知用户手机开启了无障碍模式，就可以通过动态控制前端模块展示，从而更好的隐藏无用信息、排除干扰信息（浮层弹窗、动画等）。在启无障碍模式下，设置数据埋点上报，还可以为障碍用户提供更好的体验。 希望微信小程序能尽快加强对无障碍优化开发的支持力度，让障碍群体能够享受信息化所带来的成果，享受便捷美好的生活。 无障碍体验手机开启读屏模式，扫码二维码体验： 结语京喜小程序首页无障碍优化上线后，我们对调研的障碍群体进行了回访，并且得到了不错的体验反馈。 这是我们在小程序无障碍优化上迈出的第一步，要获得更好的小程序无障碍访问体验还有很长一段路要走…… 希望此次小程序无障碍优化实践，能让障碍群体享受互联网应用所带来的便利，更好的享受生活。","pubDate":"Mon, 21 Sep 2020 09:08:08 GMT","guid":"https://aotu.io/notes/2020/09/21/jx-weapp-accessible/","category":"小程序"},{"title":"规范GIT代码提交信息&自动化版本管理","link":"https://aotu.io/notes/2020/09/10/git-commit-control/","description":"前言git作为一个开发人员必不可少的工具，代码提交也是日常一个非常频繁的操作，如果你或你的团队目前对提交信息还没有一个规范或约束，那么你有必要看看本文的内容了。 为什么要规范提交信息首先规范提交信息肯定是有必要的，简单总结下几点好处： 让项目的维护或使用人员能了解提交了哪些更改 清晰的历史记录，可能某天自己就需要查到呢 规范的提交记录可用于自动生成修改日志(CHANGELOG.MD) 基于提交类型，触发构建和部署流程 使用什么规范Conventional Commits(约定式提交规范)，是目前使用最广泛的提交信息规范，其主要受AngularJS规范的启发,下面是一个规范信息的结构：12345&lt;type&gt;[optional scope]: &lt;subject&gt;//空一行[optional body]//空一行[optional footer(s)] 规范说明type 提交的类别，必须是以下类型中的一个 12345678feat：增加一个新功能fix：修复bugdocs：只修改了文档style：做了不影响代码含义的修改，空格、格式化、缺少分号等等refactor：代码重构，既不是修复bug，也不是新功能的修改perf：改进性能的代码test：增加测试或更新已有的测试chore：构建或辅助工具或依赖库的更新 scope 可选，表示影响的范围、功能、模块 subject必填，简单说明，不超过50个字 body选填，用于填写更详细的描述 footer选填，用于填关联issus,或BREAK CHANGE BREAKING CHANGE 必须是大写，表示引入了破坏性 API 变更，通常是一个大版本的改动，BREAKING CHANGE: 之后必须提供描述，下面一个包含破坏性变更的提交示例123feat: allow provided config object to extend other configsBREAKING CHANGE: `extends` key in config file is now used for extending other config files 更详细的说明请看约定式提交规范 如何约束规范怎么确保每个提交都能符合规范呢，最好的方式就是通过工具来生成和校验，commitizen是一个nodejs命令行工具，通过交互的方式，生成符合规范的git commit，界面如下： 开始安装: 123456# 全局安装npm install -g commitizen # 或者本地安装$ npm install --save-dev commitizen# 安装适配器npm install cz-conventional-changelog packages.json在配置文件中指定使用哪种规范 123456... \"config\": &#123; \"commitizen\": &#123; \"path\": \"cz-conventional-changelog\" &#125; &#125; 安装完成后可以使用git cz 来代替git commit,然后根据提示一步步输入即可 格式校验commitlint可能你不想每次都通过交互界面来生成，还是想使用git commit -m &#39;message&#39;，那么为了确保信息的正确性，可以结合husky对提交的信息进行格式验证 安装依赖123npm install --save-dev @commitlint/&#123;config-conventional,cli&#125;# 安装huskynpm install --save-dev husky 添加 commitlint.config.js文件到项目123echo \"module.exports = &#123;extends: ['@commitlint/config-conventional']&#125;\" &gt; commitlint.config.js``` `package.json`配置 #git提交验证“husky”: { “hooks”: { “commit-msg”: “commitlint -E HUSKY_GIT_PARAMS” } },12OK到这一步就完成了，最后给你项目README.MD加上一个`commitizen-friendly`的标识吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051[![Commitizen friendly](https://img.shields.io/badge/commitizen-friendly-brightgreen.svg)](http://commitizen.github.io/cz-cli/)## 自动版本管理和生成CHANGELOG规范化的提交信息除了能很好描述项目的修改，还有一个很好的作用就是能根据提交记录来生成CHANGELOG.MD和自动生成版本号等功能。### standard-version一个用于生成`CHANGELOG.md`和进行`SemVer(语义化版本号)`发版的命令行工具主要功能：* 自动修改最新版本号，可以是`package.json`或者自定义一个文件* 读取最新版本号，创建一个最新的`git tag`* 根据提交信息，生成`CHANGELOG.md`* 创建一个新提交包括 `CHANGELOG.md`和`package.json`### 语义化版本控制(SemVer)先简单了解下什么是语义化的版本控制，其是由`GitHub`发起的一份用于规范版本号递增的规则，##### 版本格式主版本号.次版本号.修订号，版本号递增规则如下：* 主版本号(major)：当你做了不兼容的 API 修改，* 次版本号(minor)：当你做了向下兼容的功能性新增，可以理解为Feature版本，* 修订号(patch)：当你做了向下兼容的问题修正，可以理解为Bug fix版本。先行版本号可以加到“主版本号.次版本号.修订号”的后面，作为延伸。##### 先行版本当即将发布大版本改动前，但是又不能保证这个版本的功能 100% 正常，这个时候可以发布先行版本：* alpha: 内部版本* beta: 公测版本* rc: 候选版本(Release candiate)比如：1.0.0-alpha.0,1.0.0-alpha.1,1.0.0-rc.0,1.0.0-rc.1等。 `standard-version` 会根据提交的信息类型来自动更改对应的版本号,如下:* feat: 次版本(minor)+1* fix: 修订号(patch) +1* BREAK CHANGE: 主板号(marjor) +1&gt; `standard-verstion` 生成的`CHANGELOG`只会包含`feat`,`fix`,`BREACK-CHANGE`类型的提交记录#### 使用``` bashnpm i --save-dev standard-version 添加npm script 1234567&#123; scripts:&#123; \"release\": \"standard-version\", \"release:alpha\": \"standard-version --prerelease alpha\", \"release:rc\": \"standard-version --prerelease rc\" &#125;&#125; 执行：1234# npm run scriptnpm run release# or global binstandard-version 或者你想指定发行版本号： 1234#指定类型 patch/minor/marjornpm run release -- --release-as patch#指定版本号npm run release -- -- release-as 1.1.0 生命周期 prerelease:所有脚本执行之前 prebump/postbump: 修改版本号之前和之后 prechangelog/postchangelog:生成changelog和生成changelog之后 pretag/postag:生成tag标签和之后 standard-version本身只针对本地，并没有push才操作，我们可以在最后一步生成tag后，执行push操作，在paceage.json中添加12345\"standard-version\": &#123; \"scripts\": &#123; \"posttag\": \"git push --follow-tags origin master &amp;&amp; npm publish\" &#125; &#125; 还有更多配置功能自行查阅 官方文档 其它类似工具除了standard-version,还有其它类似的工具,有兴趣可以去了解下 semantic-release lerna 修改Git Commit为了使CHANGELOG.MD更能加直观看到每个版本的修改，我们尽量保证每次提交都是有意义的，但实际开发过程中，不可避免会提交了一些错误的commit message，下面介绍几个git命令来修改commit 1 修改最后一次提交git commit --amend 该命令会创建一个提交并覆盖上次提交，如果是因为写错或者不满意上次的提交信息，使用该命令就非常适合。 2 合并多条提交git reset --soft [commitID] 如果你想合并最近几条提交信息的话，那么就需要使用上面的命令来操作，指定要撤销的ccommitId,该命令会保留当前改动并撤销指定提交后的所有commit记录，如果不指定ID的话可以使用HEAD~{num} 来选择最近{num}条提交12git reset --soft HEAD~2 #合并最近两条提交git commit -m 'feat: add new feat' 带 --soft 参数的区别在于把改动内容添加到暂存区 相当于执行了git add . git rebase -igit rebase的功能会更加强大，如果我想修改最近3条提交记录，执行1git rebase -i HEAD~3 会出现如下编辑器界面(vim编辑器): 上面显示的是我最近3条提交信息 ，下面是命令说明，修改方式就是将commit信息前的pick改为你需要的命令，然后退出:wq保存 下面是常用的命令说明：123456p,pick = 使用提交r,reword = 使用提交，但修改提交说明e,edit = 使用提交，退出后使用git commit --amend 修改s,squash = 使用提交，合并前一个提交f,fixup = 和squash相同，但丢弃提交说明日志d,drop = 删除提交，丢弃提交记录 最后文本主要介绍了如何规范git commit和自动语义化版本管理，以及如何修改git commit,遵循一个规范其实没比之前随意填写信息增加多少工作量，但依赖规范却可以实现更多提升效率的事情。 参考 conventional commits standard version semver.org Semver(语义化版本号)扫盲","pubDate":"Thu, 10 Sep 2020 09:00:00 GMT","guid":"https://aotu.io/notes/2020/09/10/git-commit-control/","category":"经验分享"},{"title":"硬核看房利器——Web 全景的实现","link":"https://aotu.io/notes/2020/09/08/web-vr/","description":"疫情期间，打破社交距离限制的交互模式被推向前台，为不少行业的传统交易提供了想象的空间。 疫情时期，房地产租售业受到的冲击无疑是巨大的，由于人口流动的限制，需求量大幅减少，无法现场看房更加重了这一危机。但有危就有机，倒是意外推动了一项技术的推广——VR 看房。作为 WebVR 的子集，Web 全景是多数 WebVR 需求的降级选择，例如街景地图，本文将带大家实现一个简单的 Web 全景。","pubDate":"Tue, 08 Sep 2020 13:24:35 GMT","guid":"https://aotu.io/notes/2020/09/08/web-vr/","category":"技术预研"},{"title":"羚珑视频编辑器开发总结","link":"https://aotu.io/notes/2020/09/01/video-editor-summary/","description":"项目背景羚珑平台在静态类的设计中，已经取得了相应的成绩。在这个基础上结合当前大环境，我们认为可以去做一些动态类的设计，将动画和音效转化为可储存，可移植，可复用的数据。从而用户进行创作的时候，可以通过相对很简单的方式去使用这些高品质的动画和效果。 视频编辑器解决了什么问题？视频编辑器的主要作用是用户可以通过操作静态的PSD从而得到我们想要的动态设计效果。对比AE等复杂的视频编辑软件，学习成本大大降低，且动效的可复用性、移植性等也减轻了用户的工作量。 以下为设计效果： 开发实录如何让你的静态PSD”动”起来？参考 AE 的制作动画的过程，首先会预设剧本和分镜，其次规划好分镜中的镜头如何运动，角色如何运动，以及处理和规划素材。我们可以提炼出几个关键点：多场景、镜头移动（即场景整体的动效）、规划素材（图层内容出现时刻及时间长短灵活可控）视频编辑器操作主要涉及功能点如下： 多场景的切换与转场效果的融合，使视频效果更加生动灵活； 场景动效以及动效参数的设置，减少了同类型动效的开发（如位移动效合并为一个），也打开了设计师对动效使用的想象力，收获额外的视频效果； 图层操作，调整出现时刻及持续时间； 编辑器界面如下图： 状态管理视频编辑器的实现主要分为 5 个部分，视频预览区、动效添加区、参数编辑区、图层操作区、场景操作区，如下图其他部分的每一个操作都会映射到视频预览区，且各个部分数据共享。除此之外，编辑器的每一步操作都需要被”记住“，便于编辑的人回退、还原其操作。 经分析会涉及到以下场景，如： 预览区组件的状态需要共享 其他操作区的变动会改变预览区组件的状态 组件状态都需要可撤销/还原 我们可以采用 redux 集中管理状态以减少组件之间的数据流传递；对于撤销还原功能，我们可以采用 redux-undo，根据现有的 reducer 和配置对象，增强现有其撤消还原功能。12345678910111213141516171819202122232425262728import ReduxUndo from 'redux-undo'//定义原有的 reducerconst editReducer = (state = null, action) =&gt; &#123; switch (action.type) &#123; case VIDEO_INIT: &#123; const &#123; templates &#125; = action.payload return &#123; templates &#125; &#125; case VIDEO_TPL_CLEAR: &#123; return &#123;&#125; &#125;&#125;//通过 ReduxUndo 增强 reducer 的可撤销功能export const undoEditReducer = ReduxUndo(editReducer, &#123; initTypes: [VIDEO_TPL_CLEAR], filter: function filterActions (action, currentState, previousHistory) &#123; const &#123; isUndoIgnore = false &#125; = action return !isUndoIgnore &#125;, groupBy: groupByActionTypes([SOME_ACTION]), /* 自定义分组 groupBy:(action, currentState, previousHistory) =&gt; &#123; &#125;, */&#125;) 参数说明 initTypes：历史记录将根据初始化操作类型进行设置（重置) filter：过滤器, 可以帮助过滤掉不想在撤消/重做历史中包含的操作； groupBy：可以通过默认的 groupByActionTypes 方法将动作组合为单个撤消/重做步骤。也可以实现自定义分组行为，如果返回值不为 null，则新状态将按该返回值分组。如果下一个状态与上一个状态归为同一组，则这两个状态将在一个步骤中归为一组；如果返回值为 null，则 redux-undo 不会将下一个状态与前一个状态分组。 使用 store.dispatch() 和 Undo/Redo Actions 对你的状态执行撤消/重做操作1234567891011import &#123; ActionCreators &#125; from 'redux-undo'export const undo = () =&gt; (dispatch, getState) =&gt; &#123; dispatch(ActionCreators.undo())&#125;export const redo = () =&gt; (dispatch, getState) =&gt; &#123; dispatch(ActionCreators.redo())&#125;export const recovery = () =&gt; (dispatch, getState) =&gt; &#123; dispatch(ActionCreators.jumpToPast(0)) dispatch(ActionCreators.clearHistory())&#125; 总结 对于状态管理，首先我们可以从以下几点考虑是否需要引入redux、mobx等工具: 状态是否被多个组件或者跨页面共享； 组件状态需要跨越生命周期； 状态需要如持久化，可恢复/撤销等操作。在使用redux管理状态时，避免将所有状态抽离至redux store中，如 组件的私有状态； 组件状态传递层级较少； 当组件被unmount后可以销毁的数据等原则上是能放在组件内部就放在组件内部。其次为了状态的可读性和可操作性，在状态结构设计前，需要理清楚各个数据对象的关系，平衡数据获取及操作复杂度，推荐扁平化数据结构以减少嵌套和数据冗余。 图层交互在使用编辑器的过程中，图层的交互操作是最多最频繁的，我们参考了常用的客户端视频编辑软件 AE、Final Cut 的交互，尽可能在 Web 上提供用户操作的便利性及图层可视化，具体效果如下： 梳理图层操作需求，主要包含： 图层轨道需要伸缩 （ 调整图层持续时间 图层上的动效轨道可以单独伸缩（ 调整动效持续时间 图层轨道需要左右移动，且动效轨道跟随移动（调整出现的时刻 动效轨道可以单独左右移动 （调整动效出现的时刻 不同图层轨道可以上下调整顺序，动效轨道跟随图层轨道移动 （调整图层顺序 拖动时显示不同的外观 初始的时候首先考虑到需要移动图层顺序，我们基于 react-sortable-hoc 实现了基本的图层顺序拖曳移动 , 但是对于图层的拉伸、左右拖动处理需要自定义鼠标事件进行处理，并需要自定义计算控制图层的移动，而且最初没有考虑到拖动过程中拖动源的外观需要调整，最终，我们放弃这种实现。我们需要一个可定制化程度更高的拖曳组件，经过一番比较后，我们最终选定了 react-dnd 拖拽组件，查看其官方说明： 可帮助您构建复杂的拖放界面，同时保持组件的分离；且适用于拖动时在应用程序的不同部分之间传输数据，更完美的是组件可以响应拖放事件更改其外观和应用程序状态。 详细说明下，react-dnd 建立在 HTML5 拖放 API 之上,它可以对已拖动的 DOM 节点进行屏幕快照，并直接将其用作“拖动预览”, 简化了我们在光标移动时进行绘制的操作。不过，HTML5 拖放 API 也有一些缺点。它在触摸屏上不起作用，并且在 IE 上提供的自定义机会少于其他浏览器。这就是为什么在 react-dnd 中以可插入方式实现 HTML5 拖放支持的原因，你也可以不使用它，根据触摸事件，鼠标事件等自己来编写其他实现。 下面，我们从外到内，介绍基本的实现。 场景层面引入所需组件 12import &#123; DndProvider &#125; from 'react-dnd'import HTML5Backend from 'react-dnd-html5-backend' 将 DndProvider 放在整个场景的外层，设置 backend 为 HTML5Backend123456789&lt;DndProvider backend=&#123;HTML5Backend&#125;&gt; &lt;TemplateViewer // ----- 单个场景展示组件 template=&#123;tpl&#125; handleLayerSort=&#123;handleLayerSort&#125; onLayerDrop=&#123;onLayerDrop&#125; onLayerStretch=&#123;onLayerStretch&#125; /&gt; &lt;CustomDragLayer /&gt; // --- 自定义拖拽预览图层&lt;/DndProvider&gt; 里包含不同类型的图层组件。每个图层组件都提供一个纯渲染组件的方法 renderLayerContent，大致结构如下： 12345678export function renderLayerContent (layer) &#123; return &lt;div style=&#123;&#123;...&#125;&#125;&gt;...&lt;/div&gt;&#125;export default function XxxxLayerComponent (layer) &#123; ... return &lt;div&gt;&#123;renderLayerContent(layer)&#125;&lt;/div&gt;&#125; 里根据当前拖拽的对象的组件类型，调用相应 renderLayerContent 绘制拖拽可视内容，以实现拖拽前后的视图一致。 图层层面图层可以上下拖动，也可以左右拖动，意味它本身即是拖拽源，也是放置的目标。 为了区分拖拽的目的，我们定义了两个拖拽源12345678910111213141516const [&#123; isHorizontalDragging &#125;, horizontalDrag, preview] = useDrag(&#123; item: &#123; type: DragTypes.Horizontal, &#125;, collect: monitor =&gt; (&#123; isHorizontalDragging: monitor.isDragging(), &#125;),&#125;)const [&#123; isVerticalDragging &#125;, verticalDrag, verticalPreview] = useDrag(&#123; item: &#123; type: DragTypes.Vertical, &#125;, collect: monitor =&gt; (&#123; isVerticalDragging: monitor.isDragging(), &#125;),&#125;) 在放置处理中根据拖拽类型进行判断处理123456789const [, drop] = useDrop(&#123; accept: [DragTypes.Horizontal, DragTypes.Vertical], drop (item, monitor) &#123; // 处理左右拖动 &#125;, hover: throttle(item =&gt; &#123; // 处理上下排序 &#125;, 300),&#125;) 将定义好的拖动源和放置目标关联 DOM 。最外层 DIV 为图层可拖动区域即放置目标，然后依次为水平拖拽层，垂直拖拽层 1234567891011121314&lt;div ref=&#123;drop&#125;&gt; // --- 放置目标 DOM &lt;div ref=&#123;verticalPreview&#125;&gt; &lt;div ref=&#123;horizontalDrag&#125;&gt; // --- 水平拖拽 DOM &lt;div ref=&#123;verticalDrag&#125;&gt; // --- 垂直拖拽 DOM &lt;Icon type='drag'/&gt; &lt;/div&gt; /* 图层内容展示 */ &lt;div&gt;&#123;renderLayerContent(layer)&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 以上关于图层上下拖动、左右拖动的大体框架已经实现。 上下拖动排序时，为了拖动过程中不展示拖动源只保留生成的屏幕快照，可以根据当前的拖动状态将拖动源的透明度设置为 0 12345678&lt;div ref=&#123;drop&#125;&gt; // --- 放置目标 DOM &lt;div ref=&#123;verticalPreview&#125; style=&#123;&#123; opacity: isVerticalDragging ? 0 : 1 &#125;&#125; &gt; ... &lt;/div&gt;&lt;/div&gt; 水平拖动时，设置拖动源半透明，处理方式与上下拖动时同理。 图层内图层内有两个区域，下方区域可通过左右两端的操作点进行拉伸，上方区域可以在下方区域的宽度内左右移动以及同样通过左右两端的操作点进行拉伸。移动的实现方式前面已经介绍过就不重复了，针对拉伸的操作，我们封装一个 Stretch 类来统一处理12345678910111213141516171819202122232425function Stretch (&#123; children, left, width, onStretchEnd, onStretchMove,&#125;) &#123; function handleMouseDown (align) &#123; // 计算偏移 &#125; return ( &lt;div&gt; &#123;children&#125; &lt;div className=&#123;classnames(styles.stretch, styles.stretchHead)&#125; onMouseDown=&#123;handleMouseDown('head')&#125; /&gt; &lt;div className=&#123;classnames(styles.stretch, styles.stretchEnd)&#125; onMouseDown=&#123;handleMouseDown('end')&#125; /&gt; &lt;/div&gt; )&#125; 将需要支持拉伸的区域作为作为 Stretch 的 children 传递进来12345678&lt;div&gt; &lt;div&gt; &#123;motions.map((motion, i) =&gt; &lt;Stretch key=&#123;i&#125;&gt;&#123;/* 上方某个区域 */&#125;&lt;/Stretch&gt;)&#125; &lt;/div&gt; &lt;div&gt; &lt;Stretch&gt;&#123;/* 下方区域 */&#125;&lt;/Stretch&gt; &lt;/div&gt;&lt;/div&gt; 体验优化添加快捷键整个编辑器内容比较的多，对频繁的操作，我们可以保留常用快捷键的操作习惯。如空格播放、delete 删除等等，该功能我们可以使用 react-hot-keys 实现。 首先引入该快捷键库，然后指定绑定的快捷键，添加事件处理。123456789import Hotkeys from 'react-hot-keys'&lt;Hotkeys keyName='space' onKeyDown=&#123;(keyName, e) =&gt; &#123; e.preventDefault() play() &#125;&#125;/&gt; 文本转 SVG另外图层内容展示时有个小技巧，产品需求中文案图层平铺展示。可怜我最初竟然是通过文本长度以及轨道长度计算出文本展示次数，然后再放到 push 到节点中。经大佬改造后才明白可以将文本转化为 SVG 然后以背景图展示，真香！1234567891011&lt;div className=&#123;styles.contentText&#125; style=&#123;&#123; backgroundImage: `url(\"data:image/svg+xml;utf8, &lt;svg xmlns='http://www.w3.org/2000/svg' version='1.1' width='$&#123;size(layer.text) * 12 + 15&#125;px' height='35px'&gt; &lt;text x='10' y='22' fill='black' font-size='12'&gt; $&#123;layer.text&#125; &lt;/text&gt; &lt;/svg&gt;\")`, &#125;&#125;/&gt; 实现效果： 项目总结本文讲述了视频编辑器中操作区主要模块的处理。关于状态管理，我们主要需要明确引入管理工具的是否必要以及使用状态管理工具后是否所有状态都必须移入store中等等。另外对于复杂的图层拖拽功能，要像剥洋葱一样，先层层拆解，从而层层完善其结构。对项目而言，拿到需求后，我们从整体到局部进行分析，优先确定整体的框架、核心功能的实现方式等，进而考虑如何提高用户体验度。需求分清主次，以便于我们排列优先级从而开发提高效率。","pubDate":"Tue, 01 Sep 2020 06:36:00 GMT","guid":"https://aotu.io/notes/2020/09/01/video-editor-summary/","category":"Web开发"},{"title":"Taro 版本升级权威指南","link":"https://aotu.io/notes/2020/08/31/taro-versions/","description":"Taro 是一款由京东凹凸实验室推出的开放式跨端跨框架解决方案，致力于解决小程序、H5、React Native 的跨端同构问题，支持同时使用 React 和 Vue 来进行开发。本文由 Taro 团队成员隔壁老李撰写，旨在帮助 Taro 开发者厘清当前 Taro 多版本之间关系的那些事儿，同时解答有关 Taro 3、Taro RN 支持以及 Taro UI 的一些困惑。 自从 Taro 在今年 7 月份推出 3.0 版本，宣布同时支持 React 和 Vue 来开发跨端应用之后，Taro 的关注度得到了进一步地提升，很多开发者开始尝试升级自身项目到 3.0 来体验新的特性，同时，Taro 社区也开始迎来一些新朋友，业界有很多 Vue 开发者在做技术选型时开始将目光投向 Taro。 但由于 Taro 大版本之间差异较大，而社区内很多关于 Taro 的教程文章以及示例项目目前还停留 Taro 1/2 时代，导致很多开发者使用 Taro 3.0 尝试时出现奇怪的问题，所以 Taro 团队想通过本文帮助大家理解 Taro 各个版本之间的联系，协助大家更好地完成版本迁移，避免出现一些难以解决的奇怪问题。 区分 Taro 版本的火眼金睛Taro 目前有 3 个大版本，但如果按照架构来真正划分时代的话，Taro 1/2 属于第一代架构，而 Taro 3 则属于第二代架构，两代架构差异巨大，甚至可以完全认为是 2 个框架。当然，这只是对于框架内核而言，对于开发者，Taro 团队已经尽量在保证大版本之间的兼容性，着力降低版本迁移的难度。 Taro 1/2Taro 1/2 属于编译型架构，主要通过对类 React 代码进行语法编译转换地方式，得到各个端可以运行的代码，再配合非常轻量的运行时适配，以及根据标准组件库、API 进行差异抹平，从而实现多端适配的目的，整体架构如下。 而 Taro 1 与 Taro 2 的都是基于这种架构建立的方案，他们之间的区别主要是 Taro 1 在小程序端是自建构建体系，而 Taro 2 则是所有端都采用 Webpack 进行编译，可以降低 Taro 自身编译系统的复杂度，同时能够让开发者使用 Webpack 的生态来自定义编译过程和结果，可以认为 Taro 2 是 Taro 1 和 3 之间的一个过渡性版本。 Taro 3Taro 3 则可以大致理解为解释型架构（相对于 Taro 1/2 而言），主要通过在小程序端模拟实现 DOM、BOM API 来让前端框架直接运行在小程序环境中，从而达到小程序和 H5 统一的目的，而对于生命周期、组件库、API、路由等差异，我们依然可以通过定义统一标准，各端负责各自实现的方式来进行抹平。而正因为 Taro 3 的原理，所以我们可以在 Taro 3 中同时支持 React、Vue 等框架，甚至我们还支持了 jQuery，在不久的将来我们还能支持让开发自定义地去拓展其他框架的支持，比如 Angular，Taro 3 整体架构如下。 版本选择的取舍通过上述内容可以看出，Taro 两代架构之间差异巨大，从而也就导致了他们之间的特性也很不一样。Taro 1/2 和 Taro 3 之间特性的差异主要体现在开发体验与性能上。 从开发体验上看，Taro 3 明显是优于 Taro 1/2 的，受益于 Taro 3 架构的原理，我们可以在 Taro 3 中使用完整的 React、Vue 语法特性来进行开发，从而在开发体验上让多端开发无限接近于 Web 开发，这对深耕 Web 而初次接触小程序的开发者来说是非常友好的。而对 Taro 熟悉的朋友肯定知道 Taro 1/2 在开发时会有诸多限制，尤其是在 JSX 书写上，我们总会需要一些手段来绕过这些限制，这就导致开发体验小有不足。 从性能上看，某些情况下 Taro 1/2 会优于 Taro 3，如果你的应用非常复杂，页面节点非常多，有非常多的大规模更新操作，对性能要求比较苛刻的话，Taro 1/2 会是不错的选择，而 Taro 1 和 2 我们更推荐使用 Taro 2。当然，根据我们的测试，对于大部分应用来说 Taro 1/2 和 Taro 3 的性能差异并不明显，我们后续会给出 benchmark 来印证这一点，而且，对于 Taro 3 本身在性能存在劣势的场景，Taro 官方团队已经给出了相应的解决方案来应对。比如，提升首次渲染速度，我们可以使用预渲染；对于无限滚动加载的列表场景，我们提供了虚拟列表组件。 对于开发者来说，开发体验和性能往往是需要权衡来寻找平衡点的，缺一不可，所以现阶段，我们更加推荐使用 Taro 3 来开发多端应用。而且现阶段 Taro 团队的研发重心主要放在 Taro 3 上，新的特性会优先在 Taro 3 上进行尝试，所以，在未来 Taro 3 将更具有想象力，会有更多好玩的东西推出来。 平滑升级不完全指南Taro 2 和 Taro 3 都有对应的迁移指南，根据迁移指南往往能规避大部分的问题。 Taro 1 升级到 Taro 2 的迁移指南。 Taro 1/2 升级到 Taro 3 的迁移指南。 当然，迁移指南肯定无法覆盖到所有问题所有情况，我们在 Taro 交流群的日常交流中总是能观察到一些迁移的问题，所以在这里，我们将梳理一遍迁移指南，同时就一些常见的问题，再做一些说明补充，来解答开发者们的升级困惑。 Taro 1 升级到 Taro 2Taro 1 升 Taro 2 所需要做的工作并不多，根据迁移指南，主要是新增了一个 @tarojs/mini-runner 依赖，以及对编译配置的调整，而在这里容易出问题的往往是在编译配置调整中，所以我们总结了一下针对编译配置的调整内容。 plugins 配置调整，调整前是一个对象，调整后为一个数组，用来配置 Taro 插件，非常值得注意的是这个配置请与 babel 配置里的 plugins 区分开来，后者是用来配置 babel 插件的，这是一个非常常见的配置错误 babel、csso、uglify 等配置从旧的 plugins 配置中移出来了，调整为与 sourceRoot 和 outputRoot 等同级的配置项 weapp 配置项改名为 mini postcss 配置项下去掉 module 这一级配置，原 module 下的配置项直接置于 postcss 下 关于 async functions 的使用同时，从 Taro 2 开始，使用 async functions 不再需要安装 @tarojs/async-await 依赖了，而是通过安装 babel 插件 babel-plugin-transform-runtime 配合 babel-runtime 来实现支持，具体请查看文档异步编程指南。 而在 Taro 3 中则不再需要手动安装配置，Taro 的官方 babel 预设 babel-preset-taro 已经内置了相关配置。 Taro 1/2 升级到 Taro 3Taro 1/2 升级到 Taro 3 则相对来说要麻烦许多，但是迁移指南中其实介绍得已经非常详细了，我们在这里总结一下需要调整的内容。 文件调整文件调整主要如下： babel 配置，在项目目录下新增了 babel.config.js 配置文件来配置 babel，为此，请去掉编译配置（config/index.js）中的 babel 配置，请参见说明 项目/页面配置，新增项目/页面同名的配置文件 *.config.js（或者 *.config.ts）, * 代表页面/项目文件的文件名，config 文件必须和页面/项目文件在同一文件夹，请参见说明 编译配置调整主要参考上述 Taro 1 升级到 Taro 2 时的调整，新增 Taro 3 特有配置 framework 配置，取值为使用的框架（react, nerv, vue, vue3），请参见说明 项目依赖调整在 Taro 3 中有很多旧的项目依赖已经不再需要了，例如之前做平台运行时兼容的 @tarojs/taro-weapp、@tarojs/taro-alipay 等等，而同时也新增了一些新依赖项，例如 @tarojs/runtime 等，具体 Taro 3 会需要哪些依赖，可以通过创建 Taro 示例项目看到，在这里我们列出了 Taro 3 目前仍需使用的 NPM 包名及其具体作用。 NPM 包 描述 babel-preset-taro 给 Taro 项目使用的 babel preset @tarojs/taro 暴露给应用开发者的 Taro 核心 API @tarojs/shared Taro 内部使用的 utils @tarojs/api 暴露给 @tarojs/taro 的所有端的公有 API @tarojs/taro-h5 暴露给 @tarojs/taro 的 H5 端 API @tarojs/router Taro H5 路由 @tarojs/react 基于 react-reconciler 的小程序专用 React 渲染器 @tarojs/cli Taro 开发工具 @tarojs/extend Taro 扩展，包含 jQuery API 等 @tarojs/helper 内部给 CLI 和 runner 使用辅助方法集 @tarojs/service Taro 插件化内核 @tarojs/taro-loader 露给 @tarojs/mini-runner 和 @tarojs/webpack-runner 使用的 Webpack loader @tarojs/runner-utils 暴露给 @tarojs/mini-runner 和 @tarojs/webpack-runner 的公用工具函数 @tarojs/webpack-runner Taro H5 端 Webpack 打包编译工具 @tarojs/mini-runner Taro 小程序 端 Webpack 打包编译工具 @tarojs/components Taro 标准组件库，H5 版 @tarojs/taroize Taro 小程序反向编译器 @tarojs/with-weapp 反向转换的运行时适配器 eslint-config-taro Taro ESLint 规则 eslint-plugin-taro Taro ESLint 插件 代码调整代码调整主要如下： API 引入，前端框架（React/Nerv/Vue）自身的 API 直接从框架引入，与 Web 保持一致，只有 Taro 提供的相关 API，还是从 @tarojs/taro 引入，请参见说明 App 代码调整，对于 React/Nerv 项目，项目入口 App 的 render 函数固定修改为返回 this.props.children，如下 123456789import &#123; Component &#125; from 'react'import './app.scss'class App extends Component &#123; render() &#123; return this.props.children &#125;&#125;export default App 路由功能，使用 getCurrentInstance().router 替代 this.$router，getCurrentInstance 作为新 API 从 @tarojs/taro 引入，请参见说明 生命周期，主要是使用 React 后，带来的生命周期调整，请参见说明 使用第三方 React 库，对于 redux、mobx 等 React 生态库，可以直接像 Web 开发那样直接使用，请参见说明 Ref &amp; DOM，请参见说明 不再需要传入 $scope，在 Taro 1/2 时调用某些 API 需要传入 this.$scope，相当于传入组件对应的小程序原生对象，而 Taro 3 则不再需要，具体请参见说明 样式调整，组件直接受全局样式影响，不再需要设置 addGlobalClasses，请参见说明 当然，迁移指南内容并不仅仅局限于版本迁移，由于 Taro 3 相对与 Taro 1/2 有很多 breaking changes，所以建议使用 Taro 3 的开发者都能在开发前阅读一遍迁移指南。 不得不唠叨一下 Taro 3 的正确使用姿势正如前文所提到的，目前有很多开发者是从 Taro 3 才开始接触 Taro，而目前市面上很多 Taro 相关的教程和项目都是 Taro 1/2 的，这对于很多开发者来说会造成不小的困惑，所以行文到此，我们希望列举一些常见问题来帮助开发者规避掉一些不必要的错误。 Taro 多版本共存问题很多开发曾经使用 Taro 旧版本开发过项目，已经在全局安装了 Taro，但是想同时体验到 Taro 3，应该如何进行操作？ 我们提供了两种思路： 如果是需要新创建 Taro 3 项目，可以使用 nvm 来管理 node 版本，通过安装不同 node 版本来安装不同版本的 Taro CLI，从而解决 Taro 多版本共存的问题 如果是部分已有项目需要升级到 Taro 3，可以在这些项目本地安装相应版本的 Taro CLI，这样通过 yarn 或者 npm 执行命令的话就会直接使用本地安装的 Taro CLI，安装方式 yarn add @tarojs/cli 将 Taro CLI 版本与项目中 Taro 相关依赖的版本保持一致请时刻注意将 Taro CLI 版本与项目中 Taro 相关依赖的版本保持一致。 CLI 与项目依赖版本不一致是导致很多问题出现的源头之一。例如，Taro CLI 版本为 3.0.8，那么 Taro 相关依赖的版本也必须是 3.0.8，Taro 相关包名可以从这个列表得知，具体依赖项版本可以使用 taro info 命令或者通过 package.json 就能知晓。 如果发现不一致的情况可以使用 Taro 升级命令 taro update self [版本号] 和 taro update project [版本号]来分别将 CLI 和项目依赖升级到指定版本；或者也可以手动安装相应版本 CLI，修改 package.json 依赖版本号，然后重装依赖来解决。 使用路由在 Taro 3 中使用路由在前文的版本迁移部分已有提及，同时需要了解更多内容可以前往官方文档查看。 非常值得注意的是，无论是获取项目传入参数还是页面入参，都是通过 getCurrentInstance().router 来获取的，具体使用如下。 12345678import &#123; getCurrentInstance &#125; from '@tarojs/taro'import React, &#123; Component &#125; from 'react'export default class C extends Component &#123; componentDidMount () &#123; console.log(getCurrentInstance().router.params) &#125;&#125; 如何获取页面节点信息由于 Taro 3 设计机制的原因，需要在新增的 onReady 生命周期内才能调用 Taro API 正确获取页面节点信息，小程序和 H5 都是如此。 而同时，在微信小程序中当页面节点嵌套过深时，超过一定层级（默认 16 级，可以通过编译配置 baseLevel 来控制）时，Taro 将转而使用自定义组件，然后再开启新的循环，在这种情况要争取获取页面节点信息的话，需要使用 跨自定义组件的后代选择器 来进行选择，可以参见 Taro 相关 issue。 Taro UI 是不是不支持 Taro 3 了在 Taro 3 中依然可以使用 Taro UI，目前需要安装 Taro UI 的 alpha 版本。 1$ yarn add taro-ui@next Taro UI 作为 Taro 的官方 UI 库，依然处于维护状态，目前主要依靠社区力量在进行维护，同时也非常欢迎更多社区开发人员共同参与到 Taro UI 的迭代中来。 Taro UI 有没有 Vue 版本目前，Taro 官方没有推出 Vue 版本的 Taro UI 库，但在社区中有 Vue 版本的解决方案，如果使用 Vue 进行开发可以尝试 taro-ui-vue。 为什么 Taro 3 打包出来的应用体积巨大很多朋友会发现 Taro 3 的项目在预览的时候打包出来的包大小相比 Taro 1/2 要大上很多，然后非常紧张用了 Taro 3 会不会导致自己的主包超限。 诚然，在预览的时候 Taro 3 默认生成的包会比较大，主要是因为为了方便调试，预览时引用的 React 和 Vue 用的是调试用库，而且同时预览时会生成 sourceMap，这就导致预览时生成的包会大很多，但是在打包生产包（去掉 –watch）时，最终生成包还是会很小的，对线上不会有太大影响，同时 Taro 团队也正在尝试不断优化生产包大小，进一步优化 Taro 性能。 如果想要在预览时降低包大小，可以设置 NODE_ENV 为 production 来开启压缩，例如编译微信小程序 12345# Mac$ NODE_ENV=production taro build --type weapp --watch# Windows$ set NODE_ENV=production &amp;&amp; taro build --type weapp --watch 在 Taro 3 中使用小程序原生页面及组件在 Taro 3 中依然可以像 Taro 1/2 那样引入小程序原生页面及组件，且使用方式大体一致，不过在某些情况有些细微差别，比如 slot 的使用，在 Taro 1/2 中可以直接使用 slot 标签，而在 Taro 3 中则需要从 @tarojs/components 中引入 Slot 组件然后再进行使用。 1234567891011121314151617181920212223242526272829import Taro from '@tarojs/taro'import React, &#123; Component &#125; from 'react'import &#123; View, Text, Slot &#125; from '@tarojs/components'export default class Index extends Component &#123; state = &#123; show: false, date: '' &#125; render () &#123; const &#123; show, date &#125; = this.state return ( &lt;View className='index'&gt; &lt;van-button type='primary' onClick=&#123;this.showCalendar&#125;&gt;显示日历&lt;/van-button&gt; &lt;van-calendar show=&#123;show&#125; showConfirm type='range' onClose=&#123;this.closeCalendar&#125; onConfirm=&#123;this.onConfirm&#125; &gt; &lt;Slot name='title'&gt; &lt;View&gt;Hello world&lt;/View&gt; &lt;/Slot&gt; &lt;/van-calendar&gt; &lt;/View&gt; ) &#125;&#125; 具体使用情况可以参考项目 taro3-vant-sample。 有哪些 Taro 官方的示例项目目前 Taro 3 的社区示例项目还在完善中，Taro 官方则分别针对 React 和 Vue 提供了示例的组件库项目以供参考，安装最新版本的 Taro CLI，在创建项目时选择社区优质模板源创建即可进行体验。 同时，Taro 官方还提供了一个 TodoMVC 项目以供参考学习，React 和 Vue 示例分别在 react 和 vue 分支上。 Taro 物料市场中哪些物料能在 Taro 3 中使用目前 Taro 物料市场没有做好针对物料的版本区分，我们会尽快启动这一项工作，为每个物料打上版本标识，当下要识别哪些物料能在 Taro 3 中使用，只能通过物料本身的 Taro 依赖项来进行识别。 再聊聊 Taro 的近期动作Taro 社区及官方团队目前主要在集中人力做以下几项工作 实现支持平台与框架的自定义扩展细心的朋友应该已经发现，进入 Taro 3 时代，Taro 的推广 Slogan 已经由「多端统一开发解决方案」变成了「开放式跨端跨框架解决方案」，那么这两者之间有何差异呢？ 可以看出「开放式跨端跨框架解决方案」包含了多端统一开发的特性，同时支持跨框架开发，而且更重要的是能够成为一个开放式的解决方案，我们希望开发者可以根据 Taro 提供的 API 开发一个插件就能实现自己去为 Taro 扩展更多平台与前端框架的支持，例如未来有些新的平台推出小程序，或者有人希望能在 Taro 中使用 Angular 等更多的前端框架，那么就可以通过 Taro 的开放式机制来自行扩展，而不用等待 Taro 官方来进行支持，Taro 将只作为一个跨端适配的平台，所有的可能性都可以让社区自己去自由发掘。 实现小程序与 Web 的同构在当前 Taro 的设计下，使用 Taro 开发必须使用 Taro 标准组件库中的组件，而不能直接使用大家熟悉的 HTML 标签。我们正在努力打破这一藩篱，寻求支持让开发人员可以直接使用 HTML 标签来开发小程序的方案。 这样，既能进一步让 Taro 的开发体验接近 Web， 同时也能让一些 Web 生态资源可以直接运行在小程序中，极大降低从 Web 迁移到小程序的成本。 说说缺席的 Taro 3 RN 支持很多朋友在升级到 Taro 3 之后都会发出疑问：RN 是不再支持了吗？ Taro 3 没有支持 RN 适配，让很多使用 Taro 开发 RN 应用的朋友措手不及，经常在群里能看到上述灵魂拷问。 事实上 Taro 并没有抛弃 RN，目前 Taro 3 RN 适配工作已经由 「58 同城」开发团队接管，进行适配支持，目前这项工作已经正在紧锣密鼓进行，相信不久的将来就能看到在 Taro 3 中 RN 的支持王者归来。而这一次的通力协作也意味着 Taro 核心团队正不断成长为一个跨公司的团队，在未来一定会有更多灵感的碰撞，为社区开发者带来更多精彩的功能。 总结一下从目前的业界反馈与 Taro 自身规划来看，Taro 3 是一个非常值得尝试和期待的版本，已经有非常多的开发者开始使用 Taro 3 开发应用，在未来我们也会不断完善功能与文档，为大家带来更棒的开发体验。升级到 Taro 3 的过程或许稍显艰辛，但有任何问题，欢迎大家通过交流群和 GitHub issues 向我们进行反馈。 同时，诚挚邀请您与 Taro 官方团队交流您的使用情况，您的反馈是 Taro 前进的动力！请戳此完成 Taro 使用调研问卷，提交问卷，将有可能获得 Taro 团队的红包哦！！感谢一路相伴，Taro 有你更精彩！","pubDate":"Mon, 31 Aug 2020 16:00:00 GMT","guid":"https://aotu.io/notes/2020/08/31/taro-versions/","category":"移动开发"},{"title":"三分钟打造七夕专属的插件化脚手架","link":"https://aotu.io/notes/2020/08/25/valentine-plugin-cli/","description":"背景七夕节将至，你是否还因没有找到合适的表白机会而苦恼，还是说在纠结于为伴侣挑选合适的情人节礼物。那么今天你来对地方了。相信在读完这篇文章后，你就可以自己动手打造出一个专属于他/她/它的七夕专属插件化脚手架，通过本篇文章，不仅可以轻松拉近你与你爱人的距离，还能顺便学会插件化脚手架的相关知识。 温馨提醒本篇文章需要一定的命令行知识，若在阅读本篇文章时有任何的疑惑，可以通过自行搜索相关内容或者阅读以下的文章来解惑：https://aotu.io/notes/2016/08/09/command-line-development/index.html 废话不多说，直接进入正题 项目目录结构1234567891011121314151617181920.├── lerna.json├── package.json├── packages│ ├── cli // 七夕专属插件化cli│ │ ├── api │ │ │ ├── commandAPI.js │ │ │ ├── operateHooks.js │ │ │ └── share-utils.js│ │ ├── bin │ │ │ └── valentine│ │ ├── commands│ │ │ └── happy.js│ │ └── package.json│ └── confession // confession插件│ ├── command.config.js│ └── package.json├── scripts│ └── np.js // 用于批量部署发布脚手架和插件的定制脚本└── yarn.lock 编写插件化脚手架项目代码新建七夕项目 新建一个名为valentine的空目录并进入该目录，通过执行yarn init -y初始化目录（没安装yarn的需要安装一下yarn），同时保证node版本&gt;=10。 由于这个项目不仅有我们的核心脚手架，还存在着一些“用于表明心意”的插件，因此我们将使用monorepo的仓库结构，并安装lerna来进行仓库的管理，这里使用lerna是因为lerna能对多个packages进行统一的版本的管理。在目录下执行yarn add --dev lerna。 在目录下新建lerna.json文件，对lerna进行以下配置： 12345678&#123; \"packages\": [ \"packages/*\" ], \"version\": \"0.0.1\", \"npmClient\": \"yarn\", \"useWorkspaces\": true&#125; 在项目根目录的package.json下添加以下配置： 123456&#123; \"private\": true, \"workspaces\": [ \"packages/*\" ]&#125; 在项目的根目录下新建一个名为packages的文件夹，里面用来存放我们的核心脚手架以及插件的package。 all right，万事俱备~ 初始化脚手架package目录 进入packages文件夹，新建一个名为cli的文件夹，我们主要在这个文件夹内，对我们的脚手架核心逻辑进行编写。 进入到cli文件夹内，新建package.json文件，添加如下内容： 12345678910111213141516171819&#123; \"name\": \"@o2team/valentine-cli\", \"version\": \"0.0.1\", \"main\": \"index.js\", \"license\": \"MIT\", \"bin\": &#123; \"valentine\": \"./bin/valentine\" &#125;, \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"author\": \"\", \"description\": \"\", \"dependencies\": &#123; \"chalk\": \"^4.1.0\", \"commander\": \"^5.1.0\", \"tapable\": \"^1.1.3\" &#125;&#125; 在cli文件夹内新建bin文件夹，并进入bin文件夹内新建valentine文件，通过chmod +x ./valentine为其添加可执行权限，并在文件内写入简单的代码： 12#!/usr/bin/env nodeconsole.log('-------- 情人节快乐 --------') 在项目根目录下打开终端，运行./packages/cli/bin/valentine，顺利的话，你将在终端看到“情人节快乐”。 完善脚手架核心逻辑当然，只能打印出一个如此简单的祝福，是完全不能达不到我们开始的预期的，甚至不能称得上是一个脚手架。 不过不要着急，接下来，容我先稍微介绍一下插件化脚手架的要点，并在接下来的文章中对这些要点进行实现。 插件化的核心要点一般来说，要实现插件化，我们需要关心以下三点： 插件的安装和卸载 插件的获取和管理 插件间的通信 而由于我们目前需要插件化的是脚手架，因此我们可以通过项目依赖的方式来实现插件的安装和卸载，而脚手架本身只需要在它执行命令的项目的依赖内寻找需要加载的插件即可。 最后valentine内的大致逻辑应变为：1234567891011#!/usr/bin/env nodeconst &#123; getAllCommands,&#125; = require('../api/commandAPI.js')console.log('-------- 情人节快乐 --------')// 获取所有的命令（预设+插件）getAllCommands().forEach(cwd =&gt; &#123; // 插件注册命令行&#125;) 编写获取插件逻辑接下来，我们去实现getAllCommands的逻辑： 首先我们在cli文件夹内新建一个名为api的文件夹，用于在里面存放一些获取和加载插件的逻辑，并在api文件夹内新建commandAPI.js文件。 在commandAPI.js文件内实现getAllCommands的逻辑：123456789101112131415161718192021222324252627const fs = require('fs')const path = require('path')// 获取所有命令行命令，包括预设的以及插件的module.exports.getAllCommands = () =&gt; &#123; const cwdFns = [] const localCwdPath = path.join(__dirname, '..', 'commands') const localCwdNames = [...fs.readdirSync(localCwdPath)] localCwdNames.forEach(name =&gt; &#123; const cwdPath = path.join(localCwdPath, name) cwdFns.push(require(cwdPath)) &#125;) const &#123; getAllPluginIdOfPackageJson &#125; = require('./share-utils') getAllPluginIdOfPackageJson().forEach(name =&gt; &#123; const command = path.join(process.cwd(), 'node_modules', name, 'command.config.js') try &#123; const cwd = require(command) cwdFns.push(cwd) &#125; catch (error) &#123; console.log(`$&#123;command&#125; 不存在`) &#125; &#125;) return cwdFns&#125; 在阅读上述代码的时候，你也许会有几点疑问： localCwd是什么？为什么需要获取它？localCwd是脚手架除了插件外原本所包含的一些命令功能，为了保证引入的一致性，因此它与插件的结构本质上是相同的，所以会在获取插件命令的时候一并获取。 share-utils文件所导出的函数做了什么？是如何实现的？share-utils所导出的getAllPluginIdOfPackageJson函数主要是利用正则来匹配当前项目下符合插件命名的依赖，并把这些依赖整合导出，供脚手架使用。 12345678910111213141516171819202122const fs = require('fs')const path = require('path')const pkPluginRE = /^(@o2team\\/)valentine-plugin-/ exports.pkPluginRE = pkPluginRE exports.getAllPluginIdOfPackageJson = () =&gt; &#123; const pkgJsonPath = path.join(process.cwd(), 'package.json') const deps = &#123;&#125; const plugins = [] if (fs.existsSync(pkgJsonPath)) &#123; const pkg = require(pkgJsonPath) Object.assign(deps, pkg.devDependencies || &#123;&#125;, pkg.dependencies || &#123;&#125;) Object.keys(deps).forEach(dep =&gt; &#123; pkPluginRE.test(dep) &amp;&amp; plugins.push(dep) &#125;) &#125; return plugins &#125; 这个getAllCommands函数的整体逻辑是怎么样的？getAllCommands的其实一共做了三件事情： 一，获取脚手架内置的命令功能； 二，匹配当前项目下符合插件命名的依赖，对这些依赖进行整合并导出； 三，遍历这些插件依赖，与内置的命令功能一起，将它们的注册函数cwd导入到一个数组内，并将该数组导出。 编写注册插件和解析命令逻辑至此，我们的脚手架已经可以拿到与当前项目有关的所有插件的注册函数了，接下来我们只需要给这些注册函数传入我们的注册命令以及相关帮助函数，并在注册完成后对终端输入的命令进行解析，那么这个七夕专属的插件化脚手架就基本完成了。 同样的，我们需要改写一下cli/bin/目录下的valentine文件，改写内容如下：1234567891011121314151617#!/usr/bin/env nodeconst &#123; injectCommand, getAllCommands, commandComplete&#125; = require('../api/commandAPI.js')console.log('-------- 情人节快乐 --------')// 获取所有的命令（预设+插件）getAllCommands().forEach(cwd =&gt; &#123; // 插件注册命令行 cwd(&#123; injectCommand &#125;)&#125;)// 命令行注册完成commandComplete() 在commandAPI.js文件内添加injectCommand函数和commandComplete函数，这两个函数的逻辑并不复杂，相信读者阅读一次就能轻松理解:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475const fs = require('fs')const path = require('path')const program = require('commander')const packageConfig = require('../package.json')let status = 'pending'let cliConfig = &#123; name: '小屁', hobby: '减肥' &#125;const commandNames = ['-V', '--version', '-h', '--help']program .usage('&lt;command&gt; [options]') .version(packageConfig.version)module.exports.operateHooks = operateHooks// 为每个命令的注入函数提供所需的参数，如program等对象module.exports.injectCommand = (cmd) =&gt; &#123; if (status === 'done') return console.error('注册命令行时机已经是 done，请提前注册～') if (typeof cmd !== 'function') return console.error(cmd, '必须是一个函数') cmd(&#123; program, cliConfig &#125;)&#125;// 注册完所有命令后，检测当前命令是否存在，并更改脚手架状态module.exports.commandComplete = function() &#123; commandValidate() parseArgv() status = 'done'&#125;function parseArgv() &#123; program.parse(process.argv) program.commands.forEach(c =&gt; c.on('--help', () =&gt; console.log()))&#125;function commandValidate() &#123; program.commands.map(command =&gt; commandNames.push(command._name)) const commandName = process.argv[2] if (commandName &amp;&amp; !commandNames.includes(commandName)) &#123; console.log(chalk.red(` 没有找到 $&#123;process.argv[2]&#125; 命令 \\n`)) program.help() &#125; if (!process.argv[2]) &#123; program.help() &#125;&#125;// 获取所有命令行命令，包括预设的以及插件的module.exports.getAllCommands = () =&gt; &#123; const cwdFns = [] const localCwdPath = path.join(__dirname, '..', 'commands') const localCwdNames = [...fs.readdirSync(localCwdPath)] localCwdNames.forEach(name =&gt; &#123; const cwdPath = path.join(localCwdPath, name) cwdFns.push(require(cwdPath)) &#125;) const &#123; getAllPluginIdOfPackageJson &#125; = require('./share-utils') getAllPluginIdOfPackageJson().forEach(name =&gt; &#123; const command = path.join(process.cwd(), 'node_modules', name, 'command.config.js') try &#123; const cwd = require(command) cwdFns.push(cwd) &#125; catch (error) &#123; console.log(`$&#123;command&#125; 不存在`) &#125; &#125;) return cwdFns&#125; 编写内置插件至此，我们的插件化脚手架已经可以投入使用了，让我们来试着写一个内置的插件，在cli目录下，新建一个commands文件夹，在里面新建一个happy.js，写入如下代码：123456789101112131415module.exports = (&#123; injectCommand, operateHooks &#125;) =&gt; &#123; const &#123; hooksMap, createHook &#125; = operateHooks createHook('happyStartHook') injectCommand(function(&#123; program, cliConfig &#125;) &#123; program .command('happy') .description('情人节祝福') .action(async () =&gt; &#123; const &#123; name, hobby &#125; = cliConfig await hooksMap.happyStartHook.promise() console.log(`喜欢$&#123;hobby&#125;的$&#123;name&#125;, 祝你情人节快乐~`) &#125;) &#125;)&#125; 然后我们在cli目录下启动终端，并运行./bin/valentine happy，你将看到如下的输出： 编写非内置插件接着，我们将新建一个非内置的插件，并随后讲解插件间是如何做到通信的。首先，我们需要新建一个package，即进入到packages目录，新建一个confession文件夹，进入confession文件夹，新建package.json文件，和cli类似的写入以下内容：1234567891011&#123; \"name\": \"@o2team/valentine-plugin-confession\", \"version\": \"0.0.1\", \"main\": \"index.js\", \"license\": \"MIT\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"author\": \"\", \"description\": \"\"&#125; 在这里需要注意，package.json里的name字段可以是自定义的，但一定要和之前脚手架的share-utils内定义的正则相匹配，以便被脚手架获取插件时识别。之后，新建一个名为command.config.js的文件，同样的，写入注册函数的内容：123456789101112131415161718192021module.exports = (&#123; injectCommand &#125;) =&gt; &#123; injectCommand(function(&#123; program &#125;) &#123; program .command('love') .description('情人节表白') .action(() =&gt; &#123; logLove() &#125;) &#125;)&#125;function logLove () &#123; console.log(` ____ __ ____ _ ________ __ ______ __ __ / _/ / / / __ \\\\ | / / ____/ \\\\ \\\\/ / __ \\\\/ / / / / / / / / / / / | / / __/ \\\\ / / / / / / / _/ / / /___/ /_/ /| |/ / /___ / / /_/ / /_/ / /___/ /_____/\\\\____/ |___/_____/ /_/\\\\____/\\\\____/ `)&#125; 一个“情人节表白”插件就这样完成了，接着我们将这两个package都上传至npm，并安装到一个新的项目中，在项目下执行./node_modules/.bin/valentine love，便能看到confession插件命令被执行了： 完成插件间的通讯接下来，我们希望每次valentine happy命令被执行时，能先执行插件valentine love命令，这个时候，我们就需要往我们的插件化脚手架中加入组件的通信机制了。在这里，我们会使用tapable来实现插件间的通信，tapable是一个类似于Node.js中的EventEmitter的库，但更专注于自定义事件的触发和处理。具体的用法希望读者可以自行搜索，这里就不多介绍。 关于tapable的使用，有兴趣的同学可以戳这里了解一下： 戳这里 我们在api目录下新建一个名为operateHooks的js文件，在文件内写入以下内容：1234567891011121314151617181920212223242526272829const &#123; AsyncSeriesHook &#125; = require('tapable')module.exports = class OperateHooks &#123; constructor () &#123; this.hooksMap = &#123;&#125; this.hooksTapList = [] this.tapHook = this.tapHook.bind(this) this.bindHooks = this.bindHooks.bind(this) this.createHook = this.createHook.bind(this) &#125; createHook (nameSpace) &#123; this.hooksMap[nameSpace] = new AsyncSeriesHook() &#125; tapHook (hookName, eventName, cb) &#123; this.hooksTapList.push(&#123; hookName, eventName, cb &#125;) &#125; bindHooks () &#123; this.hooksTapList.forEach(hook =&gt; &#123; const &#123; hookName, eventName, cb &#125; = hook this.hooksMap[hookName].tapPromise(eventName, async () =&gt; &#123; await cb() &#125;) &#125;) &#125;&#125; 之后，在commandAPI中，对OperateHooks类进行实例化，并在commandComplete执行operateHooks实例的bindHooks方法，最后导出该实例。12345678910const operateHooks = new OperateHooks()module.exports.operateHooks = operateHooksmodule.exports.commandComplete = function() &#123; commandValidate() operateHooks.bindHooks() parseArgv() status = 'done'&#125; 在valentine文件中引入该实例，在进行插件命令注册时将该实例作为参数传入。123456789101112131415161718#!/usr/bin/env nodeconst &#123; injectCommand, getAllCommands, commandComplete, operateHooks&#125; = require('../api/commandAPI.js')console.log('-------- 情人节快乐 --------')// 获取所有的命令（预设+插件）getAllCommands().forEach(cwd =&gt; &#123; // 插件注册命令行 cwd(&#123; injectCommand, operateHooks &#125;)&#125;)// 命令行注册完成commandComplete() 最后分别在happy.js和confession/command.config.js对operateHooks实例进行对应钩子的创建和绑定即可：12345678910111213141516// happy.jsmodule.exports = (&#123; injectCommand, operateHooks &#125;) =&gt; &#123; const &#123; hooksMap, createHook &#125; = operateHooks createHook('happyStartHook') injectCommand(function(&#123; program, cliConfig &#125;) &#123; program .command('happy') .description('情人节祝福') .action(async () =&gt; &#123; const &#123; name, hobby &#125; = cliConfig await hooksMap.happyStartHook.promise() console.log(`喜欢$&#123;hobby&#125;的$&#123;name&#125;, 祝你情人节快乐~`) &#125;) &#125;)&#125; 12345678910111213141516171819202122232425// confession/command.config.jsmodule.exports = (&#123; injectCommand, operateHooks &#125;) =&gt; &#123; operateHooks.tapHook('happyStartHook', 'love', async () =&gt; &#123; logLove() &#125;) injectCommand(function(&#123; program &#125;) &#123; program .command('love') .description('情人节表白') .action(() =&gt; &#123; logLove() &#125;) &#125;)&#125;function logLove () &#123; console.log(` ____ __ ____ _ ________ __ ______ __ __ / _/ / / / __ \\\\ | / / ____/ \\\\ \\\\/ / __ \\\\/ / / / / / / / / / / / | / / __/ \\\\ / / / / / / / _/ / / /___/ /_/ /| |/ / /___ / / /_/ / /_/ / /___/ /_____/\\\\____/ |___/_____/ /_/\\\\____/\\\\____/ `)&#125; 待优化项目前这个插件化脚手架还存在着一些问题和可优化点： 插件的获取是通过正则匹配来进行的，这样的做法在依赖较多的仓库中效率会非常低下。 目前插件的获取形式在遇到monorepo形态的项目时，会引发项目跟目录和命令执行目录不一致的问题。 目前插件只支持项目插件，缺少了全局插件的支持。 这些优化项的可实现方法很多，由于考虑到篇幅问题，希望读者可以自己去思考，然后自行解决和优化。 最后但是，不管怎么说，一个七夕专属的插件化脚手架可以说已经完成了，最终效果： 快点拿着它和你最爱的那个他/她/它表白吧~ 项目仓库戳这里","pubDate":"Tue, 25 Aug 2020 07:21:00 GMT","guid":"https://aotu.io/notes/2020/08/25/valentine-plugin-cli/","category":"Web开发"},{"title":"京喜小程序体验评分优化实践","link":"https://aotu.io/notes/2020/08/25/jx-audit-grade-optimization/","description":"背景体验评分 Audits 是微信开发者工具内置的一项功能，会在小程序运行过程中实时检查，分析出一些可能导致体验不好的地方，并且定位出哪里有问题，以及给出一些优化建议。 京喜小程序作为京东战略级业务，拥有千万级别的流量入口，经过长时间的业务迭代，代码逻辑已经十分复杂臃肿，有迫切的性能优化需求。因此，结合体验评分功能，以京喜首页做试点，我们进行了一次体验评分的优化实践。目的是探索小程序体验评分的指标原则：拿到100分的小程序应该是什么样子的；同时希望借此给项目优化提供更多思路。 我会按照「了解首页评分现状，分析扣分项规则，解决扣分项」这个思路来介绍，就让我们开始吧～ 京喜首页评分现状打开小程序开发者工具-调试器-Audits，点击运行，操作页面滚一滚点一点，然后点击结束。 评分结果会根据评测页面内容差异、操作习惯、有无缓存有一定浮动，下图是京喜首页的一次评分：总分68，性能、体验、最佳实践都有扣分，合计8项扣分项，后面我们来逐条分析这些扣分项。 扣分项分析和优化1、使用了过大的 WXML 节点数目 得分标准：页面 WXML 节点少于 1000 个，节点树深度少于 30 层，子节点数不大于 60 个。 页面节点指标的意义在于，过大的节点数，过多过深的节点组成，都会增加内存使用，样式重排时间更长，影响体验。 现有节点2500+，想要进行优化，首先需要了解页面各个模块的节点数分布。 如何统计每个模块的节点数呢？可以使用「控制变量法」，利用性能评测工具中，节点数超过1000时会列出节点总数的能力，我们可以在总指标超过1000的情况下，每次隐藏一个模块： ​ 目标模块节点数 = 原总节点数 - 当前节点数 （实测节点数会有小范围浮动，可以测3次取平均值） 首页的模块分析图如下： ​ （第一屏） （第二屏） 简化数据如下： 观察列表可以得到两个信息：首页分为展示状态互斥的第一屏和第二屏；列表模块的节点数是大头。 因此，我们得到优化的两个方向： 页面元素按需加载，不展示时不渲染 长列表减少元素个数 第一个优化项可以通过变量控制组件显示隐藏，按需加载卸载。 第二个优化项首先想到的是减少列表接口分页数值，比如一次请求20条数据改为请求5条。但是如果接口不支持自定义分页，还可以实现更小的分页拉取吗？ 那就自己写一个分页方法的代理吧～ 思路如下： 上方为原始请求，每次20条数据，下方为代理请求的实现，每次返回5条。灰色虚线框是真实的请求数据动作，通过维护一个全量数据，需要哪页取哪页，这是示例代码： 通过以上两个优化，可以成功的把首页的页面节点数瘦身一下了，最后我们成功达到 wxml 节点总数不大于1000的目标。 2、存在图片太大而有效显示区域较小 得分标准：图片宽高乘积 &lt;= 实际显示宽高乘积 * (设备像素比 ^ 2) 简单理解是图片尺寸太大而展示尺寸太小，导致浪费网络请求时间和内存资源。 解决方案：cdn服务商一般都支持通过参数获取不同尺寸的图片，前端可以包装一个公共方法，根据页面元素尺寸拉取合适大小的图片。 此外，补充一下图片体积的内容，除了关注图片尺寸，具体的体积大小其实更值得关注，有以下两个点可以了解下： 图片类型的选择大有文章，jpg/png/gif 还有 webp 应该怎么选呢？先放一张 google 的图 这张图里未考虑 webp，加上 webp 其他类型竞争力瞬间不足了，移动端 androd 支持率基本可用，可以考虑根据设备类型渐进式使用： 利用一些压缩技术对图片进行压缩，png 推荐 https://tinypng.com/ ，压缩尺寸可观，但对图片显示质量影响甚微。 3、存在可点击元素的响应区域过小 得分标准：可点击元素的宽高都不小于 20px 移动端操作全靠手指，过小的交互区域会带来不好的体验，可以通过增大元素响应热区的方式来优化，以下方式都可以： padding 透明的border box-shadow 4、对网络请求做必要的缓存得分标准：3 分钟以内同一个url请求不出现两次回包大于 128KB 且一模一样的内容 这一项的理由是，发起网络请求总会让用户等待，可能造成不好的体验，应尽量避免多余的请求，比如对同样的请求进行缓存。 优化方式： 善用小程序的 storage 能力，做好更新和过期管理后，尽可能缓存请求到的数据。 针对确实需要多次请求的日志类接口，可以通过在参数内添加随机数或者时间戳的方式进行区分，避免误判。 5、存在短时间内发起太多的请求得分标准：通过wx.request发起的耗时超过 300ms 的请求并发数不超过 10 个。 不同于上一项，这一项关注的是接口并发数： wx.request （HTTP 连接）的最大并发限制是 10 个 wx.connectSocket （WebSocket 连接）的最大并发限制是 5 个 优化方式： 计算逻辑后移， 接口聚合 对于职责类似的网络请求，最好采用节流的方式，先在一定时间间隔内收集数据，再合并到一个请求体中发送给服务端 6、存在未绑定在wxml上的变量 得分标准：setData传入的所有数据都在模板渲染中有相关依赖 这一项考察的是 data 冗余的问题，小程序设计了渲染和逻辑分离的双线程，两边通讯通过 evaluateJavascript 转换字符串再进行拼接实现，需要非常小心两个线程之间通讯的数据量。因此，未绑定wxml的变量，最好优化成不使用 setData。 根据使用场景，可以做的优化有： 与页面展示无关的内部变量，可以挂载在组件实例上，比如维护一个 this.privateData 对象 使用小程序新版本支持的「纯数据字段」：该字段不会被传递到 wxml 内，配置正则划定它的匹配范围，可以正常使用 setData 方法，具体用法参见文档：https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/pure-data.html 但是，如果你像我一样遇到上面策略无法覆盖的场景呢？ 需要修改旧代码，配置纯数据字段的正则影响太大 京喜首页使用了 Taro 做多端适配，Taro 编译复杂逻辑的数组后会出现「影子变量」去代理逻辑，原本的数组变量被架空导致扣分 那么还有一个终极 hack 的方法： 这样 list 会被判断为有绑定节点，就不会扣分了 7、发起太多的图片请求得分标准：同域名耗时超过 100ms 的图片请求并发数不超过 20 个 最后这一项也是图片相关，发起太多图片请求会触发浏览器并行加载的限制，可能导致图片加载慢，用户一直处于等待中。 优化方式： 雪碧图 图片懒加载：小程序 Image 组件支持通过配置 lazy-load 参数来实现懒加载（https://developers.weixin.qq.com/miniprogram/dev/component/image.html ），具体判定逻辑是图片进入上下三屏就开始加载。如果需要更可控的实现，可以自己构建组件来处理。 总结做完这些优化，再测一下体验评分： 以上就是京喜首页在小程序体验评分优化方面进行的实践内容了。 总结一下，小程序性能评分可以从指标和实际数据上给我们的项目优化提供一些建议，本文主要从评分角度去分析了各种优化可能，希望能为各位小程序开发者带来参考价值。 参考资料[1] 小程序开发文档：https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AE%80%E4%BB%8B [2] Images: Your easiest page speed win: https://searchengineland.com/images-easiest-page-speed-win-269742 [3] Tiny Png: https://tinypng.com/","pubDate":"Tue, 25 Aug 2020 02:36:00 GMT","guid":"https://aotu.io/notes/2020/08/25/jx-audit-grade-optimization/","category":"小程序"},{"title":"Design Tokens —— 设计与开发碰撞的火花","link":"https://aotu.io/notes/2020/08/18/design-tokens/","description":"前言在前端的开发的过程中，和前端合作最紧密的职位应该就是设计师了。在业务流程中，设计师将自己的交互稿、视觉稿以 1px 以内误差的期望交给开发者。但在这个过程中有几个不方便的地方： 设计稿可拆解为布局、图案、文字、颜色等。其中布局、文字以及颜色这三者的样式编码需要花费前端开发者大量的时间。虽说近几年随着蓝湖等设计协同工作平台的诞生，可以在平台上获取到部分 css 代码，但是依然不能满足 web、iOS、Android 等多平台的情况； 设计稿的更新无法及时在开发者的代码中体现，一是因为开发首先需要拿到新的设计稿，再根据标注甚至肉眼判断区别后更新代码；另一方面，设计稿中看似简单的改动可能导致较大范围的代码改动，例如字体大小等。 为了解决上述的问题，完善设计和开发之间的协作流程，Design Tokens 应运而生。 什么是 Design Tokens在了解 Design Tokens 之前，需要先了解一下 Design System （即设计系统）的概念。这个概念在设计和开发的沟通流程中已经流行许久，在团队设计体系工程化的过程中不可或缺。 A Design System is the single source of truth which groups all the elements that will allow the teams to design, realize and develop a product. 设计系统能够保证项目中设计稿与开发代码的一致——设计师将设计稿件中的内容组件化，在这个系统中上传每个组件的样式、文字属性、颜色色值等。而开发者可以通过这个系统获取自己需要的组件内容。但是这样仅仅是实现了一个协作平台，那么如何解决前文提到的两个问题呢？ Design Tokens 就是解决问题的核心。 Design tokens are the visual design atoms of the design system. Design Tokens 统一了样式属性和前端语言，把每种属性都当成是一个前端变量。 举个例子，将一种颜色色值传到系统中，然后转换成 token ，前端就可以直接取这个变量使用。即使是色值被修改，当变量名不变时，对整体代码是毫无影响的，开发者要做的仅仅是重新导入一份 token。 其中 token 的语言类型可以是 css、scss、yml 等。 如何开发 Design Tokens在已知 Design Tokens 本质是一种变量的情况下，我们需要做的就是将颜色色值和文字属性变成对应的变量。 其中文字属性有比较特别的地方，它除了要把 font-family、font-size 等转换成变量之外，还需要将这些变量集合在一个 mixin 里面，方便整体使用。 所以我们需要完成的事情有如下四步，获取属性、生成变量、生成 mixin 、输出结果。其中获取属性不用多说，直接从数据库中拿到色值和文字的数据，然后分别写入 json 文件保存即可。 1.生成变量我们转换的变量类型有 css、scss、less、stylus、json、yaml、Android、iOS 八种，其中 css、scss、less、stylus、Android 这五种通过 Theo 库来实现，其余为代码手动实现。 Theo先来介绍一下 Theo,一个能够对样式进行 transform 和 format，随后输出对应变量的库。它的实现原理大致为，先将 json 文件中的值进行处理——色值处理为 rgb 或者 rgba，其余样式属性的数值进行单位统一。随后将处理过的值依据一定规则写入一个新的对象中。这个对象就是 Design Tokens。 直接上代码： 123456789101112131415161718192021static async formatWebOrtAndroid (type: string) &#123; const res = await theo .convert(&#123; transform: &#123; // 这里是类型，可以是 web或者是 android type: 'web', file: path.resolve(__dirname, 'data.json'), &#125;, format: &#123; // 这里是需要输出的变量语言类型，css、scss、less、stylus、Android 等 type, &#125; &#125;) .then(data =&gt; &#123; // 这里可以根据自己的需求进行数据处理 return data &#125;) .catch(error =&gt; console.log(`Something went wrong: $&#123;error&#125;`)) return res&#125; 自定义方法其余的 json、yaml、iOS 这三种需要我们手动实现。json 和 yaml 的实现非常简单，只需要稍微处理一下数据为我们需要的格式，然后写入 json 或者 yaml 文件即可。 iOS 略微复杂，它支持 Objective-c 和 Swift 两种类型的语言，所以要分别处理这两种语言。 Objective-c 需要分为 .h 和 .m 两个文件，对色值进行如下处理： 12345678910// 先将变量名称写入let colorsH += `- (UIColor *)$&#123;colorName&#125;;\\n`// 处理对应的变量名称下的色值let colorsM += `- (UIColor *)$&#123;colorName&#125; &#123;return [UIColor colorWithRed:($&#123;red&#125;)/255 green:($&#123;green&#125;)/255 blue:($&#123;blue&#125;)/255 alpha:($&#123;alpha&#125;)];&#125;\\n\\n`// 处理首尾colorsH = `@interface UIColor (Colors)\\n\\n$&#123;colorsH&#125;\\n@end`colorsM = `#import \"designTokenColor.h\"\\n\\n@implementation UIColor (Colors)\\n\\n$&#123;colorsM&#125;\\n@end\\n` Swift 的处理方法类似，直接上代码： 12345// 先将变量名称写入，并处理色值let colorsSwift += `class func $&#123;colorName&#125;() -&gt; UIColor&#123;\\nreturn UIColor( red: ($&#123;red&#125;)/255, green: ($&#123;green&#125;)/255, blue: ($&#123;blue&#125;)/255, alpha: ($&#123;alpha&#125;) );&#125;\\n\\n`colorsSwift = `import UIKit;\\n\\nextension UIColor&#123;\\n\\n$&#123;colorsSwift&#125;\\n&#125;\\n` 其实上述的自定义方法也可以直接定义在 Theo 中，因为 Theo 支持注册自定义 transform 事件以及自定义 format 事件，并且可以对获取到的数据进行二次处理。 2.生成 mixinmixin 是 scss 中的名称，其实就是变量的集合，能够使得一系列属性能够被整体应用。由于 Theo 没有提供对应方法，所以我们这边采用手动生成的方式。目前只针对我们需要使用的文字属性进行了构建。 我们在第一步时已经生成了所有属性的变量，所以在构建 mixin 时只需将对应变量组合在一起即可，工作量并不大。但是由于需要构建的语言类型较多，针对不同语言要输出不同格式，所以依然写了部分相似代码。 以下为不同语言下的内容生成代码： css 12345678910111213--aotu: &#123; font-family: var(--aotu-font-family); font-size: var(--aotu-font-size); font-style: var(--aotu-font-style); font-weight: var(--aotu-font-weight); letter-spacing: var(--aotu-letter-spacing); line-height: var(--aotu-line-height); opacity: var(--aotu-opacity); text-align: var(--aotu-text-align); color: var(--aotu-text-color); text-decoration: var(--aotu-text-decoration); text-transform: var(--aotu-text-transform);&#125;; scss 12345678910111213@mixin aotu () &#123; font-family: $aotu-font-family; font-size: $aotu-font-size; font-style: $aotu-font-style; font-weight: $aotu-font-weight; letter-spacing: $aotu-letter-spacing; line-height: $aotu-line-height; opacity: $aotu-opacity; text-align: $aotu-text-align; color: $aotu-text-color; text-decoration: $aotu-text-decoration; text-transform: $aotu-text-transform;&#125; less 12345678910111213.aotu () &#123; font-family: @aotu-font-family; font-size: @aotu-font-size; font-style: @aotu-font-style; font-weight: @aotu-font-weight; letter-spacing: @aotu-letter-spacing; line-height: @aotu-line-height; opacity: @aotu-opacity; text-align: @aotu-text-align; color: @aotu-text-color; text-decoration: @aotu-text-decoration; text-transform: @aotu-text-transform;&#125; Android 12345678910111213// 这里采用的是一个对象，这个对象中包含了各种数值&lt;style name=$&#123;aotu.name&#125;&gt; &lt;item name=\"android:fontFamily\"&gt;$&#123;aotu.fontFamily&#125;&lt;/item&gt; &lt;item name=\"android:textSize\"&gt;$&#123;aotu.fontSize&#125;&lt;/item&gt; &lt;item name=\"android:letterSpacing\"&gt;$&#123;aotu.letterSpacing&#125;&lt;/item&gt; &lt;item name=\"android:lineHeight\"&gt;$&#123;aotu.lineHeight&#125;&lt;/item&gt; &lt;item name=\"android:textStyle\"&gt;$&#123;aotu.fontStyle&#125;&lt;/item&gt; &lt;item name=\"android:textFontWeight\"&gt;$&#123;aotu.fontWeight&#125;&lt;/item&gt; &lt;item name=\"android:gravity\"&gt;$&#123;aotu.textAlign&#125;&lt;/item&gt; &lt;item name=\"android:textAllCaps\"&gt;$&#123;aotu.textTransform === 'uppercase'&#125;&lt;/item&gt; &lt;item name=\"android:alpha\"&gt;$&#123;aotu.opacity&#125;&lt;/item&gt; &lt;item name=\"android:textColor\"&gt;$&#123;aotu.color&#125;&lt;/item&gt;&lt;/style&gt; 至此，Design Tokens 的生成已经完成。 3.输出结果我们将输出的各种语言结果保存在不同文件中，上传到服务器，将内容和获取链接返回给用户。用户可以直接通过链接下载文件进行使用，也可手动复制内容到自己的项目中进行使用。当设计师改变设计稿时，他们需要重新上传组件内容，Design Tokens 的内容也会随之改变。而对于开发者来说，只需要重新导入一个新的链接，就可以直接完成大量代码的更新，大大提升了设计师以及开发者的效率，减少了开发者的重复工作，降低了双方沟通成本和版本迭代成本。 Design Tokens 应用Design Tokens 已经被应用在凹凸的工作流中。 一个项目开启的时候，需要先在内部夸克平台创建一个项目，项目成员包括设计师与前端开发。随后设计师使用夸克平台提供的 Sketch 插件将项目中需要的色值和本文样式都保存到项目中。以下为插件中展示效果： 设计师完成上述步骤后，开发者进入夸克平台，在对应项目中可查看色值和文字样式。其中可以看到每个属性对应的变量名，并且可以对变量名作出修改。 所有的 Design Tokens 会集中展示在单独页面中，其中包括了下载链接，开发者直接通过链接下载内容，然后应用到自己的项目代码中即可。 总结Design System 可能会是将来设计师与开发者合作的一种模式，目前相应的应用还不是非常广泛。并且一些小项目中，大家更倾向于口头交流、文件交流等，而不是花时间先去构建一个设计系统。但是随着公司或者部门项目扩张，积累变多，一个完善的设计系统以及高效的沟通平台将会是必须的。Design System 以及 Design Tokens 给我们带来了新的方式和新的可能，我们将会继续探索它。","pubDate":"Tue, 18 Aug 2020 11:44:02 GMT","guid":"https://aotu.io/notes/2020/08/18/design-tokens/","category":"Web开发"},{"title":"使用react-docgen自动生成组件文档","link":"https://aotu.io/notes/2020/07/27/how-to-use-react-docgen/","description":"背景最近在接到一个开发 React 组件库的需求，组件库在开发过程中，刚写完一个组件打算给同事用，同事立马来了个灵魂拷问“啊？这个组件怎么用”。emmm，我寻思直接告诉它下一次又忘了，还是老老实实写个文档吧。 文档写到一半，@#%#¥……#@麻烦死了。这么多组件，每个组件都需要有对应的文档，写起来太耗时了，手写文档比写个组件还麻烦。为了能快点完（xia）成（ban）任（hui）务（jia）。于是研究下那些优秀的组件库到底是怎么做的，看了下京东凹凸实验室的Quark夸克组件库的文档生成，大受启发，以下内容是讲讲关于如何优雅地偷懒并把组件文档都做好的。 为什么要自动生成文档聊这个事情之前，我们先看看文档希望长什么样子 组件文档需要什么内容 提供组件的介绍说明 提供组件的属性列表 propTypes 提供组件调用的案例 usage 提供组件调用的演示案例/源码 如果要把这些内容都通过 markdown 去写，写完耗费的时间可能比做一个简单的组件还多，为了把更多的精力投入到开发更优质的组件当中，我们需要文档生成自动化。 文档自动化后能为我们带来什么？ 统一文档格式，抹平不同开发者写文档的格式差异 节省写文档的时间来做更多有意（tou）义（lan）的事情 我们拿一个小案例来尝试一下 react-docgen开始进入正题，先简单介绍下文档自动生成的主角 react-docgen ，官方对于它的介绍是这样的： react-docgen 是一个 CLI 和工具箱，可帮助从 React 组件中提取信息并从中生成文档。它使用 ast 类型和@ babel / parser 将源解析为 AST，并提供处理此 AST 的方法以提取所需的信息。输出/返回值是一个 JSON blob / JavaScript 对象。 简单来说就是：它能提取组件的相关信息 安装用 yarn 或 npm 安装模块： 123yarn add react-docgen --devnpm install --save-dev react-docgen 关于它的 API 可以参考官方文档 https://www.npmjs.com/package/react-docgen 偷偷再分享一个高级版的 react-styleguidist https://github.com/styleguidist/react-styleguidist 例子我们先写一个人物的组件，里面包含 姓名、爱好、事件回调 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// ./Persion/index.jsximport React, &#123; Component &#125; from 'react'import PropTypes from 'prop-types'/*** 人物组件* @description 这是关于人物组件的描述内容* @class Persion* @extends &#123;Component&#125;*/class Persion extends Component &#123; /** * 处理睡觉的回调 * @param &#123;string&#125; name 姓名 */ handleSleep = (name) =&gt; &#123; console.log(`$&#123;name&#125; 开始睡觉`) this.props.onSleep() &#125; render() &#123; const &#123; name, hobbies &#125; = this.props return ( &lt;div onClick=&#123;this.handleSleep.bind(this, name)&#125;&gt; &lt;p&gt;姓名：&#123;name&#125;&lt;/p&gt; &lt;p&gt;爱好：&#123;hobbies.join(',')&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;Persion.propTypes = &#123; /** * 姓名 */ name: PropTypes.string.isRequired, /** * 爱好 */ hobbies: PropTypes.array, /** * 睡觉的事件回调 */ onSleep: PropTypes.func&#125;Persion.defaultProps = &#123; name: '张三', hobbies: ['睡觉', '打王者']&#125;export default Persion 我们定义了一个人物的组件，在组件类注释中描述了组件的基本信息, 同时在propTypes和defaultTypes中也对组件的属性参数进行了定义和属性注释 组件的基本信息都写的差不多了，那么我们先开始使用react-docgen去提取组件的相关信息。 12345678910111213// ./docgen.jsconst path = require('path')const fs = require('fs-extra')const reactDocs = require('react-docgen')const prettier = require('prettier')// 读取文件内容const content = fs.readFileSync(path.resolve('./Persion/index.jsx'), 'utf-8')// 提取组件信息const componentInfo = reactDocs.parse(content)// 打印信息console.log(componentInfo) 这里写了一个简单的读取文件和解析的过程，并把提取到的信息打印出来，以下是组件信息提取后的内容 componentInfo 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&#123; \"description\":\" 人物组件 @description 这是关于人物组件的描述内容 @class Persion @extends &#123;Component&#125;\" , \"displayName\":\"Persion\", \"methods\":[ &#123; \"name\":\"handleSleep\", \"docblock\":\" 处理睡觉的回调 @param name 姓名 \", \"modifiers\":[ ], \"params\":[ &#123; \"name\":\"name\", \"description\":\"姓名\", \"type\":&#123; \"name\":\"string\" &#125;, \"optional\":false &#125; ], \"returns\":null, \"description\":\"处理睡觉的回调\" &#125; ], \"props\":&#123; \"name\":&#123; \"type\":&#123; \"name\":\"string\" &#125;, \"required\":false, \"description\":\"姓名\", \"defaultValue\":&#123; \"value\":\"'张三'\", \"computed\":false &#125; &#125;, \"hobbies\":&#123; \"type\":&#123; \"name\":\"array\" &#125;, \"required\":false, \"description\":\"爱好\", \"defaultValue\":&#123; \"value\":\"['睡觉', '打王者']\", \"computed\":false &#125; &#125;, \"onSleep\":&#123; \"type\":&#123; \"name\":\"func\" &#125;, \"required\":false, \"description\":\"睡觉的事件回调\" &#125; &#125;&#125; 关于 react-docgen 提取的信息中，解释下下面几个参数 displayName 组件名称 description 组件的类注释 methods 组件定义的方法 props 组件的属性参数 其中这里的props是我们组件文档的核心内容，在提取的内容中，已经涵盖了属性的 属性名、属性描述、类型、默认值、是否必传。这些内容满足我们阅读组件文档所需要的属性信息。 有了所需的componentInfo信息之后，下一步我们需要把它转换成 markdown （至于为什么要用 markdown 我就不解释了 8） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// ./docgen.js// 生成markdown文档fs.writeFileSync(path.resolve('./Persion/index.md'), commentToMarkDown(componentInfo))// 把react-docgen提取的信息转换成markdown格式function commentToMarkDown(componentInfo) &#123; let &#123; props &#125; = componentInfo const markdownInfo = renderMarkDown(props) // 使用prettier美化格式 const content = prettier.format(markdownInfo, &#123; parser: 'markdown' &#125;) return content&#125;function renderMarkDown(props) &#123; return `## 参数 Props | 属性 | 类型 | 默认值 | 必填 | 描述 | | --- | --- | --- | --- | ---| $&#123;Object.keys(props) .map((key) =&gt; renderProp(key, props[key])) .join('')&#125; `&#125;function getType(type) &#123; const handler = &#123; enum: (type) =&gt; type.value.map((item) =&gt; item.value.replace(/'/g, '')).join(' \\\\| '), union: (type) =&gt; type.value.map((item) =&gt; item.name).join(' \\\\| ') &#125; if (typeof handler[type.name] === 'function') &#123; return handler[type.name](type).replace(/\\|/g, '') &#125; else &#123; return type.name.replace(/\\|/g, '') &#125;&#125;// 渲染1行属性function renderProp( name, &#123; type = &#123; name: '-' &#125;, defaultValue = &#123; value: '-' &#125;, required, description &#125;) &#123; return `| $&#123;name&#125; | $&#123;getType(type)&#125; | $&#123;defaultValue.value.replace( /\\|/g, '&lt;span&gt;|&lt;/span&gt;' )&#125; | $&#123;required ? '✓' : '✗'&#125; | $&#123;description || '-'&#125; | `&#125; 上面的转换 markdown 的代码其实做的事情比较少，主要是以下几个步骤 遍历props对象中的每个属性， 解析属性prop，提取属性名、类型、默认值、必填、描述、生成对应的 markdown 表格行。 生成 markdown 内容，通过prettier美化 markdown 代码。 经过转换后最终生成我们这个 markdown 的文件 1234567## 参数 Props| 属性 | 类型 | 默认值 | 必填 | 描述 || ------- | ------ | ------------------ | ---- | -------------- || name | string | '张三' | ✗ | 姓名 || hobbies | array | ['睡觉', '打王者'] | ✗ | 爱好 || onSleep | func | - | ✗ | 睡觉的事件回调 | 拓展优化这个案例只简单讲述了如何解析props并生成 markdown 的参数 Props模块的流程，在现实项目中，以上流程还有很多可以优化的空间，我们还可以通过很多自定义规则进行各种骚操作。 比如我们不希望把参数的数据属性（name、hobbies）和回调属性（onSleep）都放到同一个 Props 表格中，我们希望可以进行属性上的分类。 在属性描述的注释中，我们可以通过 @xx （或者 ¥%#@^!【】……你喜欢就好）进行不同的描述定义和分类，最终在属性解析的步骤中进行信息的深度的拆分解析分类，生成更加复杂多元的文档。 经过一些改造后，我们通过在注释中添加不同规则的定义描述，得到更优雅美观的文档模块 1234567891011121314151617Persion.propTypes = &#123; /** * @text 姓名 * @category data */ name: PropTypes.string.isRequired, /** * @text 爱好 * @category data */ hobbies: PropTypes.array, /** * @text 睡觉的事件回调 * @category event */ onSleep: PropTypes.func&#125; 123456789101112## 数据 Data| 属性 | 类型 | 默认值 | 必填 | 描述 || ------- | ------ | ------------------ | ---- | ---- || name | string | '张三' | ✗ | 姓名 || hobbies | array | ['睡觉', '打王者'] | ✗ | 爱好 |## 事件 Event| 属性 | 类型 | 默认值 | 必填 | 描述 || ------- | ---- | ------ | ---- | -------------- || onSleep | func | - | ✗ | 睡觉的事件回调 | 当然还有很多比如description或者methods等都可以进行不同的解析并生成对应的markdown模块，数据信息提取出来了，其实最终怎么进行ast解析取决自身的具体业务要求。 小结在日常开发的过程中，我们除了组件的代码编写外，还有很多流程上、边角上的工作需要做，这些事情往往都比较琐碎又必须要做。我们多借助工具去解决我们的工作中那些零星简单的任务，从而达到高（jiu）效（xiang）完（kuai）成（dian）工（xia）作（ban）的目标。开发者都是懒惰的（可能只有我？？），不然怎么会有这么多自动化的产物呢～ 参考资料：[1] react-docgen 仓库文档 https://github.com/reactjs/react-docgen#readme","pubDate":"Mon, 27 Jul 2020 01:00:00 GMT","guid":"https://aotu.io/notes/2020/07/27/how-to-use-react-docgen/","category":"经验分享"},{"title":"几种移动端多平台元素垂直居中解决方案总结","link":"https://aotu.io/notes/2020/07/24/line-height-in-all-hardware/","description":"前言在PC时代，垂直居中就是一个会引起很多讨论的问题，例如经典问题：如何在任何容器里，让任意行数的元素都能垂直居中，相信很多同学对于这个问题还记忆尤深。如今移动端已经成为了我们的主要平台，随之而来的问题也更加复杂。 而作为大促前端，我们的问题更加复杂，我们需要兼容大量不同平台的手机，例如：安卓4.4系统、IOS8、IOS9等等远古手机。可能有同学很好奇为何还需要花费时间去兼容这些手机，原因很简单：数据支撑，京东大促的用户量级非常巨大，虽然这些手机用户占比很少，但是当用户基数达到一定数量时，即使占比很小，数量也是很可观的，对应而来的就是各种客诉，所以我们必须兼容这些手机。 本文将从以下场景讨论问题的解决方案。 主要诉求： 文字小于12px在安卓和ios表现不同； 文字在一定宽度下自适应，超过一定宽度需要截断； 文字配图标或者其他元素； 不使用JS，纯CSS； dom节点只有2层，比如 1&lt;div&gt;&lt;span&gt;任何元素&lt;span&gt;&lt;span class=\"tag\"&gt;内容&lt;/span&gt;&lt;/div&gt;； 必须兼容IOS9及以下和安卓4.4.4，所以首先被排除的方法就是flex布局； PS. 本文不讨论PC下的展示效果 主要问题： 假如设计稿高度为28px，我们如果把行高写成28px，那么在IOS和安卓下，必然是会出bug的，相信实践过的朋友都知道，同样的行高，IOS下没什么问题，但是在安卓下，文字是偏上的，如图所示： 经典问题了，怎么解决呢，根据网上的经验，都是建议使用flex布局的align-items来布局，但是这种布局不支持4.4.4的安卓手机，所以不行，同理grid也是不行。 方法一：table布局我尝试使用了table来进行布局，如果不考虑截断的问题，是可行的，缺点是必须2层结构，否则无法实现文字截断的效果，效果如下： 代码如下：1&lt;div class=\"word\"&gt;&lt;span&gt;文字文字文字文字文字文字&lt;/span&gt;&lt;/div&gt; 1234567891011121314151617.word &#123; font-size: 10px; background: red; color: white; display: inline-table; padding: 0 10px; table-layout: fixed; width: 100px;&#125;.word span &#123; display: table-cell; height: 22px; vertical-align: middle; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125; PS:table布局同样适用于2行纯文字，但是无法截断。 方法二：line-height: normal我们还可以使用line-height: normal的方法来实现，效果如下：代码如下：1234567891011121314.word &#123; font-size: 10px; background: red; color: white; display: inline-block; padding: 3px 10px; width: 100px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125;.word span &#123; line-height: normal;&#125; 缺点：必须多套一层结构 PS:line-height: normal的元素不能设置高度，只能使用padding或者margin来模拟高度 方法三：？？？我们都知道，安卓下的文字是偏上的，所以我就把line-height加高了几个像素，奇迹发生了，安卓下居中了，IOS基本没变，绝了！经过试验，line-height值需要比height值大2px即可，IOS对这个值的敏感度非常小，只要不大于这个值，就几乎不变。 安卓：IOS：1234567891011121314&lt;div class=\"word\"&gt;文字文字文字文字文字文字&lt;/div&gt;.word &#123; font-size: 10px; background: red; color: white; display: inline-block; padding: 0 10px; line-height: 24px; height: 22px; width: 100px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125; 这个方法的应用场景在哪呢，文字+icon+需要截断+自定义宽度，经过研究，我发现，这种情况下，如果不使用js或者hack，是不可能使用纯CSS的办法完美解决的，所以使用该方法，可以保证在所有安卓和IOS的差距保持在一个设计师可以接受的范围内。 效果如下：安卓：IOS：代码如下：12345678910111213141516171819202122232425262728293031.word &#123; display: inline-block; border-radius: 4px; color: #fff; background: #E8220E; text-align: left; overflow: hidden; font-size: 20px; max-width: 180px; white-space: nowrap; vertical-align: top; padding: 0 6px 0 6px; height: 28px; line-height: 32px; &amp;__pre &#123; display: inline-block; vertical-align: top; padding-right: 4px; line-height: 30px; &#125; &amp;__text &#123; display: inline-block; vertical-align: top; width: calc(100% - 20px); text-overflow: ellipsis; white-space: nowrap; overflow: hidden; table-layout: fixed; &#125;&#125; 该方法使用了calc来计算整体宽度，来实现文字截断。这种方法能够兼容一行下的大部分情况，支持图标+文字、文字+文字。缺点：IOS下可能还是会稍偏一点点，但是根据我们设计师的反馈，该误差可以接受，且该方法支持一行多个同时出现。 总结 根据实践，大部分情况下，方法3是覆盖面比较广的方法，line-height的值 &gt; height的值即可； 如果只有一行文字，建议使用line-height: normal； 多行文字建议使用table布局，控制字数，因为无法截断；","pubDate":"Fri, 24 Jul 2020 10:00:00 GMT","guid":"https://aotu.io/notes/2020/07/24/line-height-in-all-hardware/","category":"经验分享"},{"title":"移动端吸顶导航组件的实现","link":"https://aotu.io/notes/2020/07/23/mobile-top-nav/","description":"前言吸顶导航是营销会场类最常用的组件之一， 现在的会场页面是越来越长，如果从第一屏手动滑到最后一屏，还是一个挺累的操作，所以吸顶导航还是很有必要存在的，组件很常见，但是开源的不多，而且大多是PC版，几乎都不能满足业务的需求，所以决定自己写一个。 先看下组件效果 demo 功能拆解梳理下组件需要实现的功能 到达首层吸顶和最后一层取消吸顶 当前楼层高亮显示 选中导航居中显示 默认显示或滑到首层才显示 滑动过程中控制隐藏显示 展开显示更多 功能实现下面我会介绍下其中几个功能的实现方法，全部源码有兴趣的话可以点击这里 导航选中居中1. 如何居中首先我们可以先考虑怎么居左，我们知道每一项距离左边的宽度是m，那居左就是-m,居中就是再减中线的位置，中线的位置如果是M，那就是M-m。 2. 处理边界的情况通过M-m，我们再来处理到达边界的问题，主要两种情况 1.当M-m&gt;0的时候，则已经到达最左边 2.当M-m &gt;于可滚动的距离（滚动条长度-可视长度），就是到达最右边 实现代码： 1234567891011121314151617181920212223242526272829303132/*以下代码为了方便理解，略有删减*//* * 导航切换 */watch()&#123; translateX(value)&#123; //滚动条位置修改 this.scrollView.scrollLeft = Math.abs(value) &#125;&#125;,methods:&#123; center(index)&#123; //当前选中项 const activeItem = this.$refs.navitem[index] //选中项距离左边的距离和宽度 const &#123;offsetLeft,offsetWidth&#125; = activeItem //导航条可见的宽度 const touchWidth = this.stickyNav.offsetWidth //可滚动宽度 = 整个滚动宽度 - 导航条可见的宽度 const scrollWidth = this.scrollView.scrollWidth - touchWidth //导航条中点 const half = (touchWidth - offsetWidth) / 2 //需要滚动的长度 let scrollLeft = half - offsetLeft //到达最左边 scrollLeft &gt; 0 &amp;&amp; (scrollLeft = 0); //到达最右边 scrollLeft &lt; -scrollWidth &amp;&amp; (scrollLeft = -scrollWidth) this.translateX = scrollLeft &#125;&#125; 导航缓动实现了导航居中后我们再给他加一个缓动的效果，上面已经通过监听滚动的值去修改滚动条scrollLeft改变位置，由于watch可以监听值的变化，我们可以取到初始值和结束值，所以我们只需给数字变化添加一个缓动的过程，这里使用了一个插件tweenjs来实现这个功能。1234567891011121314151617181920212223242526272829import tween from '@tweenjs/tween.js\"watch:&#123; translateX(star, end) &#123; this.tween(star,end) &#125;&#125;methods:&#123; tween(start,end)&#123; new TWEEN.Tween(&#123; number: start &#125;) .to(&#123; number: end &#125;, 100) .onUpdate(tween =&gt; &#123; //改变滚动位置 this.scrollView.scrollLeft = -tween.number; &#125;) .start(); function animate()&#123; if (TWEEN.update()) &#123; requestAnimationFrame(animate) &#125; &#125; animate() &#125;&#125; 滚动过程中的隐藏和显示实现这个功能我们需要知道用户当前的操作是上划还是下划，同样借助于vue中的watch功能，我们监听当前屏幕滚动的距离scrollTop,可以得到一个当前值和过去值，将两个值对比，当前值大于过去值的时候，则表示用户手指是向上滑（屏幕往下滚动）的，反之向下，代码如下：12345678910111213141516171819202122232425262728293031/*以下代码为了方便理解，略有删减*/data()&#123; //控制导航是否显示隐藏的变量 scrollHide:false, //需要设置一个定时器，当用户一段时间没操作的时候，显示导航条 scrollTimer:false &#125;,watch:&#123; scrollTop(newValue, oldValue)&#123; const delay = 2000 //向下滚动 if(newValue &gt; oldvalue)&#123; //改变属性，控制隐藏显示 this.scrollHide = true //清除定时器 clearTimeout(this.scrollTimer) this.scrollTimer = null //向上 &#125;else&#123; this.scrollHide = fasle &#125; if(!this.scrollTimer)&#123; this.scrollTimer = setTimeout(()=&gt;&#123; this.scrollHide = fasle &#125;) &#125; &#125;&#125; 向下滚动隐藏的功能是实现了，但还有一个问题，就是当点击导航栏的时候页面也是向下滚的，这时候还会触发上面的函数，这个时候体验效果有点奇怪，所以还需要优化下，当用户的操作是点击屏幕的时候不去执行隐藏导航的功能 改进版1234567891011121314151617181920212223242526272829303132333435363738394041424344/*以下代码为了方便理解，略有删减*/data()&#123; //控制导航是否显示隐藏的变量 scrollHide:false, //需要设置一个定时器，当用户一段时间没操作的时候，显示导航条 scrollTimer:false, //是否点击事件 isClickScroll: false&#125;,methods:&#123; //点击时触发 change(index) &#123; this.isClickScroll = true; &#125;&#125;,watch:&#123; scrollTop(newValue, oldValue)&#123; if(this.isClickScroll)&#123; setTimeout(() =&gt; &#123; this.isClickScroll = false &#125;, 10); &#125; if (this.isClickScroll) return; const delay = 2000 //向下滚动 if(newValue &gt; oldvalue)&#123; //改变属性，控制隐藏显示 this.scrollHide = true; //清除定时器 clearTimeout(this.scrollTimer); this.scrollTimer = null; //向上 &#125;else&#123; this.scrollHide = fasle; &#125; if(!this.scrollTimer)&#123; this.scrollTimer = setTimeout(()=&gt;&#123; this.scrollHide = fasle; this.isClickScroll = false; &#125;) &#125; &#125;&#125; 遇到的一些问题京东APP沉浸式兼容问题沉浸式效果： 沉浸式就是去掉了首屏标题栏的一种沉浸式体验，，如果开启了沉浸式，那么首屏标题栏是一个透明的状态，整个页面的高度就会上移，然后当你往下滑动的时候标题栏会出现，这时候导航栏如果吸顶，那么就会被标题栏给挡住看不到了，解决方法就是需要增加导航栏距离顶部的高度，而且是动态修改的，因为在APP中获取标题栏的高度是一个异步的操作，原先组件中并没考虑需要动态修改高度的情况，所以需要点小修改，先看下一开始是怎么初始化组件的： 12345678&lt;StickyNav :options=\"options\"/&gt;options:&#123; disabled:false, stickyTop:0, //距离顶部 zIndex:1000, ...&#125; 我们是通过stickyTop属性来控制导航栏距离顶部的距离，但是如果异步去修改这个对象的值是没有任何变化的，因为vue中是无法检测到对象的修改， 1.通过watch的deep属性，设置为true可以监听options对象的修改,再重新复制到新对象12345678watch&#123; options:&#123; handler(value)&#123; assign(this.stickyOptions,value) &#125;, deep:true &#125;&#125; 2.或者把stickyTop单独作为一个prop属性传给组件，这样可以实时变化 低端机兼容性问题兼容性问题通常出现在一些很低端的手机上，比如android4.0,ios8、不过如果做到以下3点基本也没什么问题 1.ES6兼容通常我们webpack上已经配置了babel转换，但其实只是对语法的编译，比如你可以使用箭头函数等如果你使用了Promise、Object.assign、includes等全局方法其实都不能被转换的，最简单的方法可以全局引入polyfill 12npm install babel-polyfill --saveimport 'babel-polyfill' 或者你的项目中只是用了一两个方法，引入整个polyfill太浪费，也可以使用一些第三方库，如 lodash/includes 2.CSS自动 -webkit- 前缀还有就是样式不生效的问题，一般我们现在都是在webpack工程中配置autoprefixer去自动加前缀，不过要注意修改下package.json下的browserslist1234\"browserslist\": [ \"Android &gt;= 4.4\", \"iOS 8\" ] 3.尽量不要使用flex布局flex布局有某些很老的机型还是支持不是很好，用inline-block来代替 结束本文到这里就结束啦，组件vue-stivky-nav已经开源到npm上，欢迎使用和提问题,如果您对本文有什么问题也可以在底下留言讨论。","pubDate":"Thu, 23 Jul 2020 10:00:00 GMT","guid":"https://aotu.io/notes/2020/07/23/mobile-top-nav/","category":"经验分享"},{"title":"如何使用Grid Layout","link":"https://aotu.io/notes/2020/07/23/how-to-use-grid-layout/","description":"如何使用Grid Layout前言CSS Grid Layout是一种栅格布局，随着各大浏览器的兼容，在可应用范围越来越广。很多人就会问能不能代替Flexbox弹性布局？虽然他们有点相似，但值得一提的是他并不能代替Flexbox弹性布局，它可以在复杂的应用场景下与Flexbox弹性布局相辅相成。该属性的理念有点类似以往在网页设计中的栅格布局，如果以前接触过网页的栅格系统会帮助理解CSS Grid Layout。 兼容性截止到20年7月14日，caniuse的兼容图。如图所示： 应用场景先来看看应用场景，个人十分推荐它用于大型页面框架构建或者电商中的sku列表摆放。具体可以来看看这两个demo图都附录了源码地址。 Demo 链接 Demo 链接 重要属性介绍①.display: grid/inline-grid;需要在包裹子元素的父容器上做出声明，该属性声明为CSS Grid Layout有两种，一种是块状元素display: grid，一种是行内块状元素display: inline-grid。该属性声明后其他属性才会有效。如图所示： Demo 链接 ②.grid-template-areas: none/itemnames;指定一个序列进行子元素排列 ③.grid-template-rows和grid-template-columnsrows是代指行，columns是代指列，用来声明高或宽 绝对值 如%，px，vw等单位 repeat() grid-template-rows: repeat(几个, 数值); grid-template-rows: repeat(几个, 多个数值); fr 如果声明的宽度为1fr，2fr，后者是前者2倍，自动划分 auto-fill 结合repeat使用 父级宽度高度限定情况下，每个item固定宽高尽可能填充 ④.grid-gap指定栅格之间的间距 ⑤.grid-auto-flow: row/column默认是row，用于指定填满的行或列的优先级。 以上②-⑤属性可以查看这个Demo 链接 扩展阅读 CSS Grid Layout Module Level 1 CSS Grid Layout Module Level 2","pubDate":"Thu, 23 Jul 2020 10:00:00 GMT","guid":"https://aotu.io/notes/2020/07/23/how-to-use-grid-layout/","category":"经验分享"},{"title":"618前端竞品分析研究（互动篇）","link":"https://aotu.io/notes/2020/07/21/618-what-taobao-do/","description":"智能化测试在互动中经常需要维护大量的状态，对这些状态进行测试验证成本较高，尤其是当有功能变动需要回归测试的时候。为了降低开发测试的成本，在这方面使用强化学习模拟用户行为，在两个方面提效： mock接口：将学习过程中的状态作为服务接口的测试数据； 回归测试：根据mock接口数据回溯到特定状态，Puppeteer根据强化学习触发前端操作，模拟真实用户行为； 什么是强化学习呢？ 强化学习是机器学习的一个领域，它强调如何基于环境行动，获取最大化的预期利益。强化学习非常适用于近几年比较流行的电商互动机制：做任务/做游戏 -&gt; 得到不同的奖励值 -&gt; 最终目标大奖，在这类型的互动游戏中，奖励是可预期的，用户的目标是使得自己的奖励最大化。这个过程可以抽象为马尔科夫决策模型：玩家（agent）通过不同的交互行为（action），改变游戏（environment）的状态（state），反馈给玩家不同的奖励 （reward）；这个过程不断循环迭代， 玩家的最终目标是奖励最大化。 接下来，我们使用比较简单的Q-learning，来实现类似的智能化测试目的。 Q-learning对于不同状态下，Q-learning的Q(s,a)表示在某一个时刻的s状态下，采取动作a可以得到的收益期望，算法的主要思想是将state和ation构建一张Q-table来存储Q值，根据Q值来选取能够获得最大收益的动作。Q值的公式计算如下： 其中，s表示state，a表示action，α为学习率，γ为衰减率，r表示action能带来的收益。 这个公式表示当前状态的Q值由“记忆中”的利益（max Q[s’,a]）和当前利益（r）结合形成。衰减率γ越高，“记忆中”的利益影响越大；学习率α越大，当前利益影响越大。Q-learning的目标是通过不断训练，最后得到一个能拿到最多奖励的最优动作序列。 在赛车游戏中，玩家的交互行为包含购买车厢、合成车厢、做任务获得金币（为了方便理解，此处简化为一个任务）；玩家从初始化状态开始，通过重复“action -&gt; 更新state”的过程，以下的伪代码简单的说明我们怎么得到一个尽量完美的Q表格： 1234567891011// action: [ 购买车厢，合成车厢，做任务获得金币 ]// state: 包含等级、拥有车厢等级、剩余金币表示初始化 Q = &#123;&#125;while Q未收敛： 初始化游戏状态state while 赛车没有达到50级： 使用策略π，获得动作a = π(S) 使用动作a，获得新的游戏状态state 更新Q，Q[s,a] ← (1-α)*Q[s,a] + α*(R(s,a) + γ* max Q[s',a]) 更新状态state 简单的demo地址：https://github.com/winniecjy/618taobao Puppeteer由上面Q-learning的训练过程，我们可以得到一系列的中间态接口作为mock数据，可以很快的回溯到特定状态进行测试，这一点在回归测试的时候十分有用。但是仅仅只是自动mock数据对效率提升还是有限，在618互动中，友商的互动团队结合Puppeteer对整个流程进行自动化测试。Puppeteer是chrome团队推出的一个工具引擎，提供了一系列的API控制Chrome，可以自动提交表单、键盘输入、拦截修改请求、保存UI快照等。 结合Puppeteer的一系列操作逻辑，部分是可以沉淀成为一个通用的测试环境的，比如： 不同用户类型，如登录、非登录、风险、会员等； 接口拦截mock逻辑； 页面快照留存； 页面性能数据留存； 其他常见的业务逻辑，如互动任务体系，跳转后等几秒后返回，加积分； … 弹窗规模化在互动中，弹窗一直是视觉表现的一个重要组成部分，对UI有比较强的定制需求。 友商的思路是将所有的逻辑尽可能的沉淀。对于电商场景来说，弹窗的业务逻辑是可穷举、可固化的，而互动场景之下，UI定制化需求很高，所以将UI层抽离， 仅对可复用的逻辑进行固化，以DSL + Runtime的机制动态下发。 结合这一套逻辑层模型，表达层/UI层也可以相应的结构化。根据项目 &gt; 场景 &gt; 图层的维度，静态配置和动态绑定相结合，搭配对应的配置平台就可以实现动态下发。 总结对于智能化测试，80%的流程其实成本是相对较低的，从测试用例的生成到puppeteer自动化测试，都是可以参考学习的，图像对比的部分需要较多训练，对于固化的功能可以进行探索，如果是新的模式性价比较低。 对于弹窗规模化，部门内部的做法是将弹窗沉淀成一个通用的组件，只包含通用的兼容逻辑，包括显示/隐藏、弹窗出现底层禁止滚动、多弹窗层级问题等。对于UI和其他业务逻辑，复用性较低，所以每次都是重写。这种做法尽可能地保持了组件的通用性，在会场线比较适用，因为会场线的弹窗一般不包含业务逻辑（如抽奖、PK等），但是对于互动线来说，复用的内容相较于弹窗的“重量”来说显得有些微不足道。 友商的沉淀思路前提在于上游接口的逻辑需要可复用，上游逻辑如果无法固定下来，前端的互动逻辑也较难固化。总体来说，友商在互动方面的沉淀思路大部分是从开发提效出发，主要供给内部使用；京东内部已有类似的互动提效方案终极目标是盈利，如京喜的社交魔方平台和最近正在成型的满天星平台，所以沉淀方式都是以成套的H5。 参考[1] 生产力再提速，618互动项目进化之路[2] 机器学习相关教程 - 莫烦[3] Puppeteer docs","pubDate":"Tue, 21 Jul 2020 10:00:00 GMT","guid":"https://aotu.io/notes/2020/07/21/618-what-taobao-do/","category":"经验分享"},{"title":"Webpack原理浅析","link":"https://aotu.io/notes/2020/07/17/webpack-analize/","description":"背景Webpack 迭代到4.x版本后，其源码已经十分庞大，对各种开发场景进行了高度抽象，阅读成本也愈发昂贵。但是为了了解其内部的工作原理，让我们尝试从一个最简单的 webpack 配置入手，从工具设计者的角度开发一款低配版的 Webpack。","pubDate":"Fri, 17 Jul 2020 06:34:02 GMT","guid":"https://aotu.io/notes/2020/07/17/webpack-analize/","category":"Web开发"},{"title":"京喜前端自动化测试之路(小程序篇)","link":"https://aotu.io/notes/2020/07/13/jx-automated-testing-weapp/","description":"如果你已经阅读过 “京喜前端自动化测试之路（一）”，可跳过前言部分阅读。 前言京喜（原京东拼购）项目，作为京东战略级业务，拥有千万级别的流量入口。为了保障线上业务的稳定运行，每月例行开展前端容灾演习，主要包含小程序及 H5 版本，要求各页面各模块在异常情况下进行适当的降级处理，不能出现空窗、样式错乱、不合理的错误提示等体验问题。 容灾演习是一项长期持续的工作，且涉及页面功能及场景多，人工的切换场景模拟异常导致演习效率较低，因此想通过开发自动化测试工具来提升演习效率，让容灾演习工作随时可以轻松开展。由于京喜 H5 和小程序场景差异比较大，自动化测试分 H5 和小程序两部分进行。前期已经分享过 H5 的自动化测试方案 —— 京喜前端自动化测试之路（一），本文则主要讲述小程序版的自动化测试方案。 综上所述，我们希望京喜小程序自动化测试工具可以提供以下功能： 访问目标页面，对页面进行截图； 模拟用户点击、滑动页面操作； 网络拦截、模拟异常情况（接口响应码 500、接口返回数据异常）； 操作缓存数据（模拟有无缓存的场景等）。 小程序自动化 SDK聊到小程序的自动化工具，微信官方为开发者提供了一套小程序自动化 SDK —— miniprogram-automator ， 我们不需要关注技术选型，可直接使用。 小程序自动化 SDK 为开发者提供了一套通过外部脚本操控小程序的方案，从而实现小程序自动化测试的目的。 如果你之前使用过 Selenium WebDriver 或者 Puppeteer，那你可以很容易快速上手。小程序自动化 SDK 与它们的工作原理是类似的，主要区别在于控制对象由浏览器换成了小程序。 特性 通过该 SDK，你可以做到以下事情： 控制小程序跳转到指定页面 获取小程序页面数据 获取小程序页面元素状态 触发小程序元素绑定事件 往 AppService 注入代码片段 调用 wx 对象上任意接口 … 示例123456789101112131415const automator = require('miniprogram-automator')automator .launch(&#123; cliPath: '/Applications/wechatwebdevtools.app/Contents/MacOS/cli', // 工具 cli 位置（绝对路径） projectPath: 'path/to/project', // 项目文件地址（绝对路径） &#125;) .then(async miniProgram =&gt; &#123; const page = await miniProgram.reLaunch('/pages/index/index') await page.waitFor(500) const element = await page.$('.banner') console.log(await element.attribute('class')) await element.tap() await miniProgram.close() &#125;) 综上所述，我们选择使用官方维护的 SDK —— miniprogram-automator 开发小程序的自动化测试工具，通过 SDK 提供的一系列 API ，实现访问目标页面、模拟异常场景、生成截图的过程自动化。最后再通过人工比对截图，判断页面降级处理是否符合预预期、用户体验是否友好。 实现方案原来的容灾演习过程： 小程序的通信方式改成 HTTPS ，通过 Whistle 对接口返回进行修改来模拟异常情况，验证各页面各模块的降级处理符合预期。 现阶段的容灾演习自动化方案： 我们将容灾演习过程分为自动化流程和人工操作两部分。 自动化流程： 启动微信开发者工具（开发版）; 访问目标页面，模拟用户点击、滑动等行为； 模拟异常场景：拦截网络请求，修改接口返回数据（接口返回 500、异常数据等）； 生成截图。 人工操作： 自动化脚本执行完毕后，人工比对各个场景的截图，判断是否符合预期。 方案流程图： 开发实录快速创建测试用例为了提高测试脚本的可维护性、扩展性，我们将测试用例的信息都配置到 JSON 文件中，这样编写测试脚本的时候，我们只需关注测试流程的实现。 测试用例 JSON 数据配置包括公用数据（global）和私有数据： 公用数据（global）：各测试用例都需要用到的数据，如：模拟访问的目标页面地址、名字、描述、设备类型等。 私有数据： 各测试用例特定的数据，如测试模块信息、api 地址、测试场景、预期结果、截图名字等数据。 1234567891011121314151617181920212223242526272829303132333435363738394041424344&#123; \"global\": &#123; \"url\": \"/pages/index/index\", \"pageName\": \"index\", \"pageDesc\": \"首页\", \"device\": \"iPhone X\" &#125;, \"homePageApi\": &#123; \"id\": 1, \"module\": \"home_page_api\", \"moduleDesc\": \"首页主接口\", \"api\": \"https://xxx\", \"operation\": \"模拟响应码 500\", \"expectRules\": [ \"1. 有缓存数据，显示容灾兜底数据\", \"2. 请求容灾接口，显示容灾兜底数据\", \"3. 容灾接口异常，显示信异常息、刷新按钮\", \"4. 恢复网络，点击刷新按钮，显示正常数据\" ], \"screenshot\": [ &#123; \"name\": \"normal\", \"desc\": \"正常场景\" &#125;, &#123; \"name\": \"500_cache\", \"desc\": \"有缓存-主接口返回500\" &#125;, &#123; \"name\": \"500_no_cache\", \"desc\": \"无缓存-主接口返回500-容灾兜底数据\" &#125;, &#123; \"name\": \"500_no_cache_500_disaster\", \"desc\": \"无缓存-主接口返回500-容灾兜底接口返回500\" &#125;, &#123; \"name\": \"500_no_cache_recover\", \"desc\": \"无缓存-返回500-恢复网络\" &#125; ] &#125;, …&#125; 编写测试脚本我们以京喜首页主接口的测试用例为例子，通过模拟主接口返回 500 响应码的异常场景，验证主接口的异常处理机制是否完善、用户体验是否友好。 预期效果： 主接口异常，有缓存数据，显示缓存数据 主接口异常，无缓存数据，则请求容灾接口，显示容灾兜底数据 主接口、容灾接口异常，无缓存数据，显示信异常息、刷新按钮 恢复网络，点击刷新按钮，显示正常数据 测试流程： 场景实现： 根据测试流程以及配置的测试用例信息，编写测试脚本，模拟测试用例场景: 访问页面 123456const miniProgram = await automator.launch(&#123; cliPath: '/Applications/wechatwebdevtools.app/Contents/MacOS/cli', // 开发者工具命令行工具（绝对路径） projectPath: 'jx_project', // 项目地址（绝对路径）&#125;)await miniProgram.reLaunch('/pages/index/index') 生成截图 123await miniProgram.screenshot(&#123; path: 'jx_weapp_index_home_page_500.png'&#125;) 模拟异常数据 12345678910111213141516171819202122232425262728293031323334353637383940414243const getMockData = (url, mockType, mockValue) =&gt; &#123; const result = &#123; data: 'test', cookies: [], header: &#123;&#125;, statusCode: 200, &#125; switch (mockType) &#123; case 'data': result.data = getMockResponse(url, mockValue) // 修改返回数据 break case 'cookies': result.cookies = mockValue // 修改返回数据 break case 'header': result.header = mockValue // 修改返回响应头 break case 'statusCode': result.statusCode = mockValue // 修改返回响应头 break &#125; return &#123; rule: url, result &#125; &#125; // 修改本地存储数据 const mockValue = &#123; data: &#123; modules: [&#123; tpl:'3000', content: [] &#125;] &#125; &#125; const mockData = [ getMockData(api1, 'statusCode', 500), // 模拟接口返回 500 getMockData(api2, 'data', mockValue) // 模拟接口返回异常数据 ... ] 拦截接口请求，修改返回数据 123456789101112131415161718192021222324252627282930const interceptAPI = async (miniProgram, url, mockData) =&gt; &#123; try &#123; await miniProgram.mockWxMethod( 'request', function(obj, data) &#123; // 处理返回函数 for (let i = 0, len = data.length; i &lt; len; i++) &#123; const item = data[i] // 命中规则的返回 mockData if (obj.url.indexOf(item.rule) &gt; -1) &#123; return item.result &#125; &#125; // 没命中规则的真实访问后台 return new Promise(resolve =&gt; &#123; obj.success = res =&gt; resolve(res) obj.fail = res =&gt; resolve(res) / origin 指向原始方法 this.origin(obj) &#125;) &#125;, mockData, // 传入 mock 数据 ) &#125; catch (e) &#123; console.error(`拦截【$&#123;url&#125;】API报错`) console.error(e) &#125; &#125;await interceptAPI(interceptAPI, url, mockData) miniProgram.mockWxMethod：覆盖 wx 对象上指定方法的调用结果。利用该 API，可以覆盖 wx.request API，拦截网络请求，修改返回数据。 目前是本地存储一份接口返回的 JSON 数据，通过修改本地的 JSON 数据生成 mockData。若需要修改接口实时返回的数据，可在 obj.success 中获取实时数据并修改。 清除缓存 123456try &#123; await miniProgram.callWxMethod('clearStorage')&#125; catch (e) &#123; await console.log(`清除缓存报错: `) await console.log(e)&#125; 点击刷新按钮 123const page = await miniProgram.currentPage()const $refreshBtn = await page.$('.page-error__refresh-btn') // 同 WXSS，仅支持部分 CSS 选择器await $refreshBtn.tap() 取消拦截，恢复网络 12345678910const cancelInterceptAPI = async (miniProgram) =&gt; &#123; try &#123; await miniProgram.restoreWxMethod('request') // 重置 wx.request ，消除 mockWxMethod 调用的影响。 &#125; catch (e) &#123; console.error(`取消拦截【$&#123;url&#125;】API报错`) console.error(e) &#125;&#125;await cancelInterceptAPI(miniProgram) 启动自动化测试由于第一阶段的测试工具尚未平台化，先通过在终端输入命令行，运行脚本的方式，启动自动化测试。 在项目的 package.json 文件中，使用 scripts 字段定义脚本命令： 123\"scripts\": &#123; \"start\": \"node pages/index/index.js\" &#125;, 运行环境： 安装 Node.js 并且版本大于 8.0 基础库版本为 2.7.3 及以上 开发者工具版本为 1.02.1907232 及以上 运行： 在终端切入到项目根目录路径，输入以下命令行，就可以启动测试工具，运行测试脚本。 1$ npm run start 测试结果人工比对截图结果： 运行脚本示例： 使用 SDK，你必须知道 Shadow DOM当我们想控制小程序页面时，需获取页面实例 page，利用 page 提供的方法控制页面内的元素。 比如，当我们想点击页面中搜索框时，我们一般会这么做：123const page = await miniProgram.currentPage()const $searchBar = await page.$('search-bar')await $searchBar.tap() 但这样真的可行吗？答案是： 试试就知道了。 运行这段测试脚本后生成的截图： 我们得到的结果是：根本没有触发点击事件。 Shadow DOM： 它是 HTML 的一个规范，它允许在文档( document )渲染时插入一颗DOM元素子树，但是这个子树不在主 DOM 树中。 它允许浏览器开发者封装自己的 HTML 标签、css 样式和特定的 javascript 代码、同时开发人员也可以创建类似 &lt;input&gt;、&lt;video&gt;、&lt;audio&gt; 等、这样的自定义的一级标签。创建这些标签内容相关的 API，可以被叫做 Web Component。 Shadow DOM 的关键所在，它可以将一个隐藏的、独立的 DOM 附加到一个元素上。 Shadow host: 一个常规 DOM 节点，Shadow DOM 会被附加到这个节点上。它是 Shadow DOM 的一个宿主元素。比如：&lt;input /&gt;、&lt;audio&gt;、&lt;video&gt; 标签，就是 Shadow DOM 的宿主元素。 Shadow tree: Shadow DOM 内部的 DOM 树。 Shadow root: Shadow DOM 的根节点。通过 createShadowRoot 返回的文档片段被称为 shadow-root , 它和它的后代元素，都会对用户隐藏。 回到我们刚刚的问题： 由于小程序使用了 Shadow DOM，因此我们不能直接通过 page 实例获取到搜索框真实 DOM。我们看到的页面中渲染的搜索框，实际上是一个 Shadow DOM。因此，我们必须先获取到搜索框 Shadow DOM 的宿主元素，并通过宿主元素获取到搜索框真实的 DOM，最后触发真实 DOM 的点击事件。 1234const page = await miniProgram.currentPage()const $searchBarShadow = await page.$('search-bar')const $searchBar = await $searchBarShadow.$('.search-bar')const &#123; height &#125; = await $searchBar.size() 运行这段测试脚本后生成的截图： 从截图可以看到，触发了搜索框的点击事件。 更多测试场景实现1. 下拉刷新12345678const pullDownRefresh = async (miniProgram) =&gt; &#123; try &#123; await miniProgram.callWxMethod('startPullDownRefresh') &#125; catch (e) &#123; console.error('下拉刷新操作失败') console.error(e) &#125;&#125; 2. 滚动到指定 DOM 12345const page = await miniProgram.currentPage() // 获取页面实例const $recommendTabShadow = await page.$('recommend-tab') // 获取Shadow DOMconst $recommendTab = await $recommendTabShadow.$('.recommend') // 获取真实 DOMconst &#123; top &#125; = await $recommendTab.offset() // 获取DOM 定位await miniProgram.pageScrollTo(top) // 滚动到指定DOM 3. 事件 日志打印； 监听页面崩溃事件 12345678910// 日志打印时触发miniProgram.on('console', msg =&gt; &#123; console.log(msg.type, msg.args) &#125;)&#125;)// 页面 JS 出错时触发page.on('error', (e) =&gt; &#123; console.log(e)&#125;) 结语第一阶段的小程序自动化测试之路告一段落。和 H5 自动化测试一样，容灾演习已实现了半自动化，可通过在终端运行测试脚本，模拟异常场景自动生成截图，再配合人工比对截图操作，判断演习结果是否符合预期。目前已投入到每个月的容灾演习中使用。 由于 H5 和小程序的差异比较大，第一阶段的自动化测试分两端进行，测试脚本语法也是截然不同，需要同时维护两套测试工具。为了降低维护成本，提升测试脚本的开发效率，我们正在研发第二阶段的自动化测试工具，一套代码支持两端测试，目前已经进入内测阶段。更多彩蛋，敬请期待第二阶段自动化测试工具——多端自动化测试 SDK 。","pubDate":"Mon, 13 Jul 2020 09:58:08 GMT","guid":"https://aotu.io/notes/2020/07/13/jx-automated-testing-weapp/","category":"小程序"},{"title":"Taro 3 正式版发布：开放式跨端跨框架解决方案","link":"https://aotu.io/notes/2020/06/30/taro-3-0-0/","description":"Taro 3 正式版发布：开放式跨端跨框架解决方案从 Taro 第一个版本发布到现在，Taro 已经接受了来自于开源社区两年多的考验。今天我们很高兴地在党的生日发布 Taro 3（Taro Next）正式版，希望 Taro 未来的更多两年能像一名共产主义战士一样经受住更多的考验。以下是 Taro 3 的一些新增特性：","pubDate":"Tue, 30 Jun 2020 16:00:00 GMT","guid":"https://aotu.io/notes/2020/06/30/taro-3-0-0/","category":"小程序"},{"title":"手把手教你写个小程序定时器管理库","link":"https://aotu.io/notes/2020/06/22/timer-miniprogram/","description":"背景凹凸曼是个小程序开发者，他要在小程序实现秒杀倒计时。于是他不假思索，写了以下代码： 123456789Page(&#123; init: function () &#123; clearInterval(this.timer) this.timer = setInterval(() =&gt; &#123; // 倒计时计算逻辑 console.log('setInterval') &#125;) &#125;,&#125;) 可是，凹凸曼发现页面隐藏在后台时，定时器还在不断运行。于是凹凸曼优化了一下，在页面展示的时候运行，隐藏的时候就暂停。 1234567891011121314151617181920Page(&#123; onShow: function () &#123; if (this.timer) &#123; this.timer = setInterval(() =&gt; &#123; // 倒计时计算逻辑 console.log('setInterval') &#125;) &#125; &#125;, onHide: function () &#123; clearInterval(this.timer) &#125;, init: function () &#123; clearInterval(this.timer) this.timer = setInterval(() =&gt; &#123; // 倒计时计算逻辑 console.log('setInterval') &#125;) &#125;,&#125;) 问题看起来已经解决了，就在凹凸曼开心地搓搓小手暗暗欢喜时，突然发现小程序页面销毁时是不一定会调用 onHide 函数的，这样定时器不就没法清理了？那可是会造成内存泄漏的。凹凸曼想了想，其实问题不难解决，在页面 onUnload 的时候也清理一遍定时器就可以了。 123456Page(&#123; ... onUnload: function () &#123; clearInterval(this.timer) &#125;,&#125;) 这下问题都解决了，但我们可以发现，在小程序使用定时器需要很谨慎，一不小心就会造成内存泄漏。后台的定时器积累得越多，小程序就越卡，耗电量也越大，最终导致程序卡死甚至崩溃。特别是团队开发的项目，很难确保每个成员都正确清理了定时器。因此，写一个定时器管理库来管理定时器的生命周期，将大有裨益。 思路整理首先，我们先设计定时器的 API 规范，肯定是越接近原生 API 越好，这样开发者可以无痛替换。 1234function $setTimeout(fn, timeout, ...arg) &#123;&#125;function $setInterval(fn, timeout, ...arg) &#123;&#125;function $clearTimeout(id) &#123;&#125;function $clearInterval(id) &#123;&#125; 接下来我们主要解决以下两个问题 如何实现定时器暂停和恢复 如何让开发者无须在生命周期函数处理定时器 如何实现定时器暂停和恢复思路如下: 将定时器函数参数保存，恢复定时器时重新创建 由于重新创建定时器，定时器 ID 会不同，因此需要自定义全局唯一 ID 来标识定时器 隐藏时记录定时器剩余倒计时时间，恢复时使用剩余时间重新创建定时器 首先我们需要定义一个 Timer 类，Timer 对象会存储定时器函数参数，代码如下 123456789101112131415161718192021222324class Timer &#123; static count = 0 /** * 构造函数 * @param &#123;Boolean&#125; isInterval 是否是 setInterval * @param &#123;Function&#125; fn 回调函数 * @param &#123;Number&#125; timeout 定时器执行时间间隔 * @param &#123;...any&#125; arg 定时器其他参数 */ constructor (isInterval = false, fn = () =&gt; &#123;&#125;, timeout = 0, ...arg) &#123; this.id = ++Timer.count // 定时器递增 id this.fn = fn this.timeout = timeout this.restTime = timeout // 定时器剩余计时时间 this.isInterval = isInterval this.arg = arg &#125; &#125; // 创建定时器 function $setTimeout(fn, timeout, ...arg) &#123; const timer = new Timer(false, fn, timeout, arg) return timer.id &#125; 接下来，我们来实现定时器的暂停和恢复，实现思路如下： 启动定时器，调用原生 API 创建定时器并记录下开始计时时间戳。 暂停定时器，清除定时器并计算该周期计时剩余时间。 恢复定时器，重新记录开始计时时间戳，并使用剩余时间创建定时器。 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344class Timer &#123; constructor (isInterval = false, fn = () =&gt; &#123;&#125;, timeout = 0, ...arg) &#123; this.id = ++Timer.count // 定时器递增 id this.fn = fn this.timeout = timeout this.restTime = timeout // 定时器剩余计时时间 this.isInterval = isInterval this.arg = arg &#125; /** * 启动或恢复定时器 */ start() &#123; this.startTime = +new Date() if (this.isInterval) &#123; /* setInterval */ const cb = (...arg) =&gt; &#123; this.fn(...arg) /* timerId 为空表示被 clearInterval */ if (this.timerId) this.timerId = setTimeout(cb, this.timeout, ...this.arg) &#125; this.timerId = setTimeout(cb, this.restTime, ...this.arg) return &#125; /* setTimeout */ const cb = (...arg) =&gt; &#123; this.fn(...arg) &#125; this.timerId = setTimeout(cb, this.restTime, ...this.arg) &#125; /* 暂停定时器 */ suspend () &#123; if (this.timeout &gt; 0) &#123; const now = +new Date() const nextRestTime = this.restTime - (now - this.startTime) const intervalRestTime = nextRestTime &gt;=0 ? nextRestTime : this.timeout - (Math.abs(nextRestTime) % this.timeout) this.restTime = this.isInterval ? intervalRestTime : nextRestTime &#125; clearTimeout(this.timerId) &#125;&#125; 其中，有几个关键点需要提示一下： 恢复定时器时，实际上我们是重新创建了一个定时器，如果直接用 setTimeout 返回的 ID 返回给开发者，开发者要 clearTimeout，这时候是清除不了的。因此需要在创建 Timer 对象时内部定义一个全局唯一 ID this.id = ++Timer.count，将该 ID 返回给 开发者。开发者 clearTimeout 时，我们再根据该 ID 去查找真实的定时器 ID (this.timerId)。 计时剩余时间，timeout = 0 时不必计算；timeout &gt; 0 时，需要区分是 setInterval 还是 setTimeout，setInterval 因为有周期循环，因此需要对时间间隔进行取余。 setInterval 通过在回调函数末尾调用 setTimeout 实现，清除定时器时，要在定时器增加一个标示位（this.timeId = “”）表示被清除，防止死循环。 我们通过实现 Timer 类完成了定时器的暂停和恢复功能，接下来我们需要将定时器的暂停和恢复功能跟组件或页面的生命周期结合起来，最好是抽离成公共可复用的代码，让开发者无须在生命周期函数处理定时器。翻阅小程序官方文档，发现 Behavior 是个不错的选择。 Behaviorbehaviors 是用于组件间代码共享的特性，类似于一些编程语言中的 “mixins” 或 “traits”。每个 behavior 可以包含一组属性、数据、生命周期函数和方法，组件引用它时，它的属性、数据和方法会被合并到组件中，生命周期函数也会在对应时机被调用。每个组件可以引用多个 behavior，behavior 也可以引用其他 behavior 。 123456789101112131415161718192021222324// behavior.js 定义behaviorconst TimerBehavior = Behavior(&#123; pageLifetimes: &#123; show () &#123; console.log('show') &#125;, hide () &#123; console.log('hide') &#125; &#125;, created: function () &#123; console.log('created')&#125;, detached: function() &#123; console.log('detached') &#125;&#125;)export &#123; TimerBehavior &#125;// component.js 使用 behaviorimport &#123; TimerBehavior &#125; from '../behavior.js'Component(&#123; behaviors: [TimerBehavior], created: function () &#123; console.log('[my-component] created') &#125;, attached: function () &#123; console.log('[my-component] attached') &#125;&#125;) 如上面的例子，组件使用 TimerBehavior 后，组件初始化过程中，会依次调用 TimerBehavior.created() =&gt; Component.created() =&gt; TimerBehavior.show()。因此，我们只需要在 TimerBehavior 生命周期内调用 Timer 对应的方法，并开放定时器的创建销毁 API 给开发者即可。思路如下： 组件或页面创建时，新建 Map 对象来存储该组件或页面的定时器。 创建定时器时，将 Timer 对象保存在 Map 中。 定时器运行结束或清除定时器时，将 Timer 对象从 Map 移除，避免内存泄漏。 页面隐藏时将 Map 中的定时器暂停，页面重新展示时恢复 Map 中的定时器。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const TimerBehavior = Behavior(&#123; created: function () &#123; this.$store = new Map() this.$isActive = true &#125;, detached: function() &#123; this.$store.forEach(timer =&gt; timer.suspend()) this.$isActive = false &#125;, pageLifetimes: &#123; show () &#123; if (this.$isActive) return this.$isActive = true this.$store.forEach(timer =&gt; timer.start(this.$store)) &#125;, hide () &#123; this.$store.forEach(timer =&gt; timer.suspend()) this.$isActive = false &#125; &#125;, methods: &#123; $setTimeout (fn = () =&gt; &#123;&#125;, timeout = 0, ...arg) &#123; const timer = new Timer(false, fn, timeout, ...arg) this.$store.set(timer.id, timer) this.$isActive &amp;&amp; timer.start(this.$store) return timer.id &#125;, $setInterval (fn = () =&gt; &#123;&#125;, timeout = 0, ...arg) &#123; const timer = new Timer(true, fn, timeout, ...arg) this.$store.set(timer.id, timer) this.$isActive &amp;&amp; timer.start(this.$store) return timer.id &#125;, $clearInterval (id) &#123; const timer = this.$store.get(id) if (!timer) return clearTimeout(timer.timerId) timer.timerId = '' this.$store.delete(id) &#125;, $clearTimeout (id) &#123; const timer = this.$store.get(id) if (!timer) return clearTimeout(timer.timerId) timer.timerId = '' this.$store.delete(id) &#125;, &#125;&#125;) 上面的代码有许多冗余的地方，我们可以再优化一下，单独定义一个 TimerStore 类来管理组件或页面定时器的添加、删除、恢复、暂停功能。 1234567891011121314151617181920212223242526272829303132333435class TimerStore &#123; constructor() &#123; this.store = new Map() this.isActive = true &#125; addTimer(timer) &#123; this.store.set(timer.id, timer) this.isActive &amp;&amp; timer.start(this.store) return timer.id &#125; show() &#123; /* 没有隐藏，不需要恢复定时器 */ if (this.isActive) return this.isActive = true this.store.forEach(timer =&gt; timer.start(this.store)) &#125; hide() &#123; this.store.forEach(timer =&gt; timer.suspend()) this.isActive = false &#125; clear(id) &#123; const timer = this.store.get(id) if (!timer) return clearTimeout(timer.timerId) timer.timerId = '' this.store.delete(id) &#125;&#125; 然后再简化一遍 TimerBehavior 1234567891011121314151617181920212223242526const TimerBehavior = Behavior(&#123; created: function () &#123; this.$timerStore = new TimerStore() &#125;, detached: function() &#123; this.$timerStore.hide() &#125;, pageLifetimes: &#123; show () &#123; this.$timerStore.show() &#125;, hide () &#123; this.$timerStore.hide() &#125; &#125;, methods: &#123; $setTimeout (fn = () =&gt; &#123;&#125;, timeout = 0, ...arg) &#123; const timer = new Timer(false, fn, timeout, ...arg) return this.$timerStore.addTimer(timer) &#125;, $setInterval (fn = () =&gt; &#123;&#125;, timeout = 0, ...arg) &#123; const timer = new Timer(true, fn, timeout, ...arg) return this.$timerStore.addTimer(timer) &#125;, $clearInterval (id) &#123; this.$timerStore.clear(id) &#125;, $clearTimeout (id) &#123; this.$timerStore.clear(id) &#125;, &#125;&#125;) 此外，setTimeout 创建的定时器运行结束后，为了避免内存泄漏，我们需要将定时器从 Map 中移除。稍微修改下 Timer 的 start 函数，如下： 123456789101112131415161718192021222324class Timer &#123; // 省略若干代码 start(timerStore) &#123; this.startTime = +new Date() if (this.isInterval) &#123; /* setInterval */ const cb = (...arg) =&gt; &#123; this.fn(...arg) /* timerId 为空表示被 clearInterval */ if (this.timerId) this.timerId = setTimeout(cb, this.timeout, ...this.arg) &#125; this.timerId = setTimeout(cb, this.restTime, ...this.arg) return &#125; /* setTimeout */ const cb = (...arg) =&gt; &#123; this.fn(...arg) /* 运行结束，移除定时器，避免内存泄漏 */ timerStore.delete(this.id) &#125; this.timerId = setTimeout(cb, this.restTime, ...this.arg) &#125;&#125; 愉快地使用从此，把清除定时器的工作交给 TimerBehavior 管理，再也不用担心小程序越来越卡。 123456789101112131415161718192021222324252627import &#123; TimerBehavior &#125; from '../behavior.js'// 在页面中使用Page(&#123; behaviors: [TimerBehavior], onReady() &#123; this.$setTimeout(() =&gt; &#123; console.log('setTimeout') &#125;) this.$setInterval(() =&gt; &#123; console.log('setTimeout') &#125;) &#125;&#125;)// 在组件中使用Components(&#123; behaviors: [TimerBehavior], ready() &#123; this.$setTimeout(() =&gt; &#123; console.log('setTimeout') &#125;) this.$setInterval(() =&gt; &#123; console.log('setTimeout') &#125;) &#125;&#125;) npm 包支持为了让开发者更好地使用小程序定时器管理库，我们整理了代码并发布了 npm 包供开发者使用，开发者可以通过 npm install --save timer-miniprogram 安装小程序定时器管理库，文档及完整代码详看 https://github.com/o2team/timer-miniprogram eslint 配置为了让团队更好地遵守定时器使用规范，我们还可以配置 eslint 增加代码提示，配置如下： 123456789101112131415161718// .eslintrc.jsmodule.exports = &#123; 'rules': &#123; 'no-restricted-globals': ['error', &#123; 'name': 'setTimeout', 'message': 'Please use TimerBehavior and this.$setTimeout instead. see the link: https://github.com/o2team/timer-miniprogram' &#125;, &#123; 'name': 'setInterval', 'message': 'Please use TimerBehavior and this.$setInterval instead. see the link: https://github.com/o2team/timer-miniprogram' &#125;, &#123; 'name': 'clearInterval', 'message': 'Please use TimerBehavior and this.$clearInterval instead. see the link: https://github.com/o2team/timer-miniprogram' &#125;, &#123; 'name': 'clearTimout', 'message': 'Please use TimerBehavior and this.$clearTimout instead. see the link: https://github.com/o2team/timer-miniprogram' &#125;] &#125;&#125; 总结千里之堤，溃于蚁穴。 管理不当的定时器，将一点点榨干小程序的内存和性能，最终让程序崩溃。 重视定时器管理，远离定时器泄露。 参考小程序开发者文档","pubDate":"Mon, 22 Jun 2020 04:00:00 GMT","guid":"https://aotu.io/notes/2020/06/22/timer-miniprogram/","category":"Web开发"},{"title":"图形处理：给 Canvas 文本填充线性渐变","link":"https://aotu.io/notes/2020/06/22/linearGradient/","description":"在 Canvas 中对文本填充水平或垂直的线性渐变可以轻易实现，而带角度的渐变就复杂很多；就好像下面这样，假设文本矩形宽为 W, 高为 H, 左上角坐标为 X, Y。 猜想与答案给出两个答案： 正确答案是图二，因为这样得出来的坐标生成的渐变最紧接文本矩形边界，它的运动轨迹如下动图： (图来源：Do you really know CSS linear-gradients） 渐变起点与终点坐标的计算所以，渐变的起点与终点坐标该怎么计算呢？答: 先求得起点与终点的长度（距离）。 根据长度与文本矩形的中心点坐标分别计算出起点与终点坐标。 线性渐变长度的计算 W3C 给出了一个公式（A 表示角度）： 1gradientLineLength = abs(W * sin(A)) + abs(H * cos(A)) 不过，该公式主要应用于 CSS 的线性渐变设置，即以 12 点钟方向为 0°，顺时针旋转。 而我们需要的是以 3 点钟方向为 0°，逆时针旋转，即公式为： 1234gradientLineLength = abs(W * cos(A)) + abs(H * sin(A))// 半长：halfGradientLineLength = (abs(W * cos(A)) + abs(H * sin(A))) / 2 那么这个公式是怎么来的呢？以下是笔者的求解： 由图可得以下方程组： 因此可推导出： 化简后为： 所以 c1 + c2 为： 由三角函数平方公式知：cos(A) * cos(A) = 1 - sin(A) * sin(A)， 代入 c1 + c2： 第一步化简后： 最后的结果就是： 因为 sin, cos 在函数周期内存在负值（见下面角度对应的三角函数周期图），所以线性渐变的长度需要取绝对值。 至此，我们知道了线性渐变长度，文本矩形的中心点坐标很好算，即： 12centerX = X + W / 2centerY = Y + H / 2 所以，起点与终点的坐标分别为： 12345startX = centerX - cos(A) * halfGradientLineLengthstartY = centerY + sin(A) * halfGradientLineLengthendX = centerX + cos(A) * halfGradientLineLengthendY = centerY - sin(A) * halfGradientLineLength 看看最终效果 经验注释进行三角函数计算时，应尽量避免先用 tan, 因为 tan 在其周期内存在无穷值，需要做特定的条件判断，而 sin, cos 没有此类问题，代码书写更为简洁清晰并且不会因疏忽产生错误，见下面三角函数与角度的对应关系周期图。 参阅：Do you really know CSS linear-gradients? MDN linear-gradient W3C - CSS Images Module Level 3 # linear-gradients","pubDate":"Mon, 22 Jun 2020 02:00:00 GMT","guid":"https://aotu.io/notes/2020/06/22/linearGradient/","category":"Web开发"},{"title":"向强大的SVG迈进","link":"https://aotu.io/notes/2020/06/09/strong-svg/","description":"SVG 即 Scalable Vector Graphics 可缩放矢量图形，使用XML格式定义图形。 一、SVG印象SVG 的应用十分广泛，得益于 SVG 强大的各种特性。 1.1、 矢量可利用 SVG 矢量的特点，描出深圳地铁的轮廓： 1.2、iconfontSVG 可依据一定的规则，转成 iconfont 使用： 1.3、 foreignObject利用 SVG 的 foreignObject 标签实现截图功能，原理：foreignObject 内部嵌入 HTML 元素： 12345&lt;svg xmlns=\"http://www.w3.org/2000/svg\"&gt; &lt;foreignObject width=\"120\" height=\"60\"&gt; &lt;p style=\"font-size:20px;margin:0;\"&gt;凹凸实验室 欢迎您&lt;/p&gt; &lt;/foreignObject&gt;&lt;/svg&gt; 截图实现流程： 首先声明一个基础的 svg 模版，这个模版需要一些基础的描述信息，最重要的，它要有 &lt;foreignObject&gt;&lt;/foreignObject&gt; 这对标签； 将要渲染的 DOM 模版模版嵌入 foreignObject 即可； 利用 Blob 构建 svg 对象； 利用 URL.createObjectURL(svg) 取出 URL。 1.4、SVG SMIL由于微信编辑器不允许嵌入 &lt;style&gt;&lt;script&gt;&lt;a&gt; 标签，利用SVG SMIL 可进行微信公众号极具创意的图文排版设计，包括动画与交互。但是也要注意，标签里不允许有id，否则会被过滤或替换掉。 点击 “凹凸实验室” 后，围绕 “凹凸实验室” 中心旋转 360度，点击0.5秒后 出现 https://aotu.io/ ，动画只运行一次。 下图为 GIF循环演示： 代码如下：12345678910111213141516171819&lt;svg width=\"360\" height=\"300\" xmlns=\"http://www.w3.org/2000/svg\"&gt; &lt;g&gt; &lt;!-- 点击后 运行transform旋转动画，restart=\"never\"表示只运行一次 --&gt; &lt;animateTransform attributeName=\"transform\" type=\"rotate\" begin=\"click\" dur=\"0.5s\" from=\"0 100 80\" to=\"360 100 80\" fill=\"freeze\" restart=\"never\" /&gt; &lt;g&gt; &lt;text font-family=\"microsoft yahei\" font-size=\"20\" x=\"50\" y=\"80\"&gt; 凹凸实验室 &lt;/text&gt; &lt;/g&gt; &lt;g style=\"opacity: 0;\"&gt; &lt;!-- 同一个初始位置以及大致的宽高，触发点击事件 --&gt; &lt;text font-family=\"microsoft yahei\" font-size=\"20\" x=\"50\" y=\"80\"&gt;https://aotu.io/&lt;/text&gt; &lt;!-- 点击后 运行transform移动动画，改变文本的位置 --&gt; &lt;animateTransform attributeName=\"transform\" type=\"translate\" begin=\"click\" dur=\"0.1s\" to=\"0 40\" fill=\"freeze\" restart=\"never\" /&gt; &lt;!-- 点击0.5秒后 运行opacity显示动画 --&gt; &lt;animate attributeName=\"opacity\" begin=\"click+0.5s\" from=\"0\" to=\"1\" dur=\"0.5s\" fill=\"freeze\" restart=\"never\" /&gt; &lt;/g&gt; &lt;/g&gt;&lt;/svg&gt; 以上是鄙人对SVG的大致印象，最近的需求开发再次刷新了我的认知，那就是 SVG实现非比例缩放 以及 小程序不支持SVG标签的处理，下面容我来讲述一番。 二、SVG 实现非比例缩放我们熟知的 iconfont，可通过改变字体大小缩放，但是这是 比例缩放，那如何实现 SVG 的非比例缩放呢？如下图所示，如何将 一只兔子 非比例缩放？ 划重点：实现非比例缩放主要涉及三个知识点：viewport、viewBox和preserveAspectRatio，viewport 与viewBox 结合可实现缩放的功能，viewBox 与 preserveAspectRatio 结合可实现非比例的功能。 2.1、viewportviewport 表示SVG可见区域的大小。viewport 就像是我们的显示器屏幕大小，超出区域则隐藏，原点位于左上角，x 轴水平向右，y 轴垂直向下。 通过类似CSS的属性 width、height 指定视图大小： 1&lt;svg width=\"400\" height=\"200\"&gt;&lt;/svg&gt; 2.2、viewBoxviewBox值有4个数字：x, y, width, height 。其中 x：左上角横坐标，y：左上角纵坐标，width：宽度，height：高度。原点默认位于左上角，x 轴水平向右，y 轴垂直向下。 1&lt;svg width=\"400\" height=\"200\" viewBox=\"0 0 200 100\"&gt;&lt;/svg&gt; 显示器屏幕的画面，可以特写，可以全景，这就是 viewBox。viewBox 可以想象成截屏工具选中的那个框框，和 viewport 作用的结果就是 把框框中的截屏内容再次在 显示器 中全屏显示。 （图片来源：SVG 研究之路 (23) - 理解 viewport 與 viewbox） 2.3、preserveAspectRatio上图的红色框框和蓝色框框，恰好和显示器的比例相同，如果是下图的绿色框框，怎样在显示器屏幕中显示呢？ 2.3.1、 定义preserveAspectRatio 作用的对象是 viewBox，使用方法如下：12preserveAspectRatio=\"[defer] &lt;align&gt; [&lt;meetOrSlice&gt;]\"// 例如 preserveAspectRatio=\"xMidYMid meet\" 其中 defer 此时不是重点，暂且忽略，主要了解 align 和 meetOrSlice 的 用法： align：由两个名词组成，分别代表 viewbox 与 viewport 的 x 方向、y方向的对齐方式。 值 含义 xMin viewport 和 viewBox 左边对齐 xMid viewport 和 viewBox x轴中心对齐 xMax viewport 和 viewBox 右边对齐 YMin viewport 和 viewBox 上边缘对齐。注意Y是大写。 YMid viewport 和 viewBox y轴中心点对齐。注意Y是大写。 YMax viewport 和 viewBox 下边缘对齐。注意Y是大写。 meetOrSlice：表示如何维持高宽的比例，有三个值 meet、slice、none。 meet - 默认值，保持纵横比缩放 viewBox 适应 viewport，可能会有余留的空白。 slice - 保持纵横比同时比例小的方向放大填满 viewport，超出的部分被剪裁掉。 none - 扭曲纵横比以充分适应 viewport。 2.3.2、 例子例子1：preserveAspectRatio=&quot;xMidYMid meet&quot; 表示 绿色框框 与 显示器的 x 方向、y方向的 中心点 对齐； 例子2：preserveAspectRatio=&quot;xMidYMin slice&quot; 表示 绿色框框 与 显示器的 x 方向 中心点 对齐，Y 方向 上边缘对齐，保持比例放大填满 显示屏 后超出部分隐藏； 例子3：preserveAspectRatio=&quot;xMidYMid slice&quot; 表示 绿色框框 与 显示器的 x 方向、y方向的 中心点 对齐，保持比例放大填满显示屏 后超出部分隐藏； 例子4：preserveAspectRatio=&quot;none&quot; 不管三七二十一，随意缩放绿色框框，填满 显示屏即可；这就是非比例缩放的答案了。 三、小程序不支持svg标签怎么办微信小程序官方不支持 SVG 标签的，但是决定曲线救国，相当于自己实现了一个SVG标签：使用小程序内置的 Canvas 渲染器， 在 Cax 中实现 SVG 标准的子集，使用 JSX 或者 HTM（Hyperscript Tagged Markup） 描述 SVG 结构行为表现。 但是今天我想讲讲其他的。我们知道，小程序虽然不支持 SVG 标签，但是支持 svg 转成 base64 后作为 background-image 的 url，如 background-image: url(&quot;data:image/svg+xml.......) 。 但是我这边还有个需求，随时更改 SVG 每个路径的颜色，即 颜色可配置： 来回转 Base64 肯定是比较麻烦的，有没有更好的方式呢？直接贴答案：对于SVG图形，还有更好的实现方式，就是直接使用SVG XML格式代码，无需进行base64转换。 3.1、URL 编码直接使用 SVG XML 格式代码，首先要了解 Data URI的格式。划重点：base64非必选项，不指定的时候，后面的 &lt;data&gt; 将使用 URL编码。 3.1.1、入门 百分号编码(Percent-encoding), 也称作URL编码(URL encoding)，是特定上下文的统一资源定位符 (URL)的编码机制。 原理：ASCII 字符 = % + 两位 ASCII 码（十六进制）。例如，字符 a 对应的 ASCII 码为 0x61，那么 URL 编码后得到 %61 。 3.1.2、URL 编码压缩前言： Data URI 的格式中的 &lt;data&gt; 完全使用URL 编码也是可以的，如 encodeURIComponent(&#39;&lt;svg version=&quot;1.1&quot; viewBox= …&lt;/svg&gt;&#39;)。但是和转义前原始SVG相比，可读性差了很多，而且占用体积也变大了。如果深入了解URL 编码的话，&lt;data&gt; 没必要全部编码的。 正文： RFC3986文档规定，URL中只允许包含 未保留字符 以及 所有保留字符。 未保留字符：包含英文字母（a-zA-Z）、数字（0-9）、-_.~ 4个特殊字符。对于未保留字符，不需要百分号编码。 保留字符：具有特殊含义的字符 :/?#[]@ (分隔Url的协议、主机、路径等组件) 和 !$&amp;&#39;()*+,;= （用于在每个组件中起到分隔作用的，如&amp;符号用于分隔查询多个键值对）。 受限字符或不安全字符：直接放在Url中的时候，可能会引起解析程序的歧义，因此这部分需要百分号编码，如%、空格、双引号&quot;、尖号 &lt;&gt;等等。 综上所述，只需要对 受限字符或不安全字符 进行编码即可。 JS 处理比较简单，利用 replace 将 需要编码的字符 替换掉 即可，基本替换 以下的符号 就够用了： 1234567891011121314svgToUrl (svgData) &#123; encoded = encoded .replace(/&lt;!--(.*)--&gt;/g, '') // 亲测必须去掉注释 .replace(/[\\r\\n]/g, ' ') // 亲测最好去掉换行 .replace(/\"/g, `'`) // 单引号是保留字符，双引号改成单引号减少编码 .replace(/%/g, '%25') .replace(/&amp;/g, '%26') .replace(/#/g, '%23') .replace(/&#123;/g, '%7B') .replace(/&#125;/g, '%7D') .replace(/&lt;/g, '%3C') .replace(/&gt;/g, '%3E') return `data:image/svg+xml,$&#123;encoded&#125;` &#125; 如果使用在 CSS 中，可利用 SASS版本3.3以上 的 三个API 对 SVG字符串做替换处理。 str_insert(string, insert, index)： 从 $string 第 $index 插入字符 $insert； str_index(string, substring): 返回 $substring 在 $string 中第一个位置； str_slice(string, start_at, end_at = nil): 返回从字符 $string 中第 $start_at 开始到 $end_at 结束的一个新字符串。 前人已有总结，可前往 https://github.com/leeenx/sass-svg/blob/master/sass-encodeuri.scss 查看完整代码。 3.2、SVG 压缩 一般从 Sketch 导出 SVG ，冗余代码比较多，有条件的话建议使用 SVGO 压缩SVG的原本体积，比如清除换行、重复空格；删除文档声明；删除注释；删除desc描述等等。 四、总结SVG强大的地方在于，出其不意，炫酷，与众不同。 无论是微信公众号花式排版，foreignObject 标签实现截图，实现非比例缩放，或者 背景图直接使用 SVG XML 格式代码，还是上文没有提及的路径动画、描边动画、图形裁剪、滤镜等等，都可以玩出新的花样。 SVG 一个属性可成就一篇文章，学习 SVG 可以说是在挑战自己，欢迎加入 SVG 的学习队列。 五、参考内容 · 推荐阅读三看 SVG Web 动效URL编码的奥秘学习了，CSS中内联SVG图片有比Base64更好的形式超级强大的SVG SMIL animation动画详解详细教你微信公众号正文页SVG交互开发SVG 简介与截图等应用","pubDate":"Tue, 09 Jun 2020 06:00:00 GMT","guid":"https://aotu.io/notes/2020/06/09/strong-svg/","category":"Web开发 移动开发"},{"title":"前端也要懂物理 —— 惯性滚动篇","link":"https://aotu.io/notes/2020/06/08/momentum-scrolling/","description":"我们在平时编程开发时，除了需要关注技术实现、算法、代码效率等因素之外，更要把所学到的学科知识（如物理学、理论数学等等）灵活应用，毕竟理论和实践相辅相成、密不可分，这无论是对于我们的方案选型、还是技术实践理解都有非常大的帮助。今天就让我们一起来回顾中学物理知识，并灵活运用到惯性滚动的动效实现当中。 惯性滚动（也叫 滚动回弹，momentum-based scrolling）最早是出现在 iOS 系统中，是指 当用户在终端上滑动页面然后把手指挪开，页面不会马上停下而是继续保持一定时间的滚动效果，并且滚动的速度和持续时间是与滑动手势的强烈程度成正比。抽象地理解，就像高速行驶的列车制动后依然会往前行驶一段距离才会最终停下。而且在 iOS 系统中，当页面滚动到顶/底部时，还有可能触发 “回弹” 的效果。这里录制了微信 APP 【账单】页面中的 iOS 原生时间选择器的惯性滚动效果： 熟悉 CSS 开发的同学或许会知道，在 Safari 浏览器中有这样一条 CSS 规则： 1-webkit-overflow-scrolling: touch; 当其样式值为 touch 时，浏览器会使用具有回弹效果的滚动, 即“当手指从触摸屏上移开，内容会继续保持一段时间的滚动效果”。除此之外，在丰富多姿的 web 前端生态中，很多经典组件的交互都一定程度地沿用了惯性滚动的效果，譬如下面提到的几个流行 H5 组件库中的例子。 流行 UI 库效果为了方便对比，我们先来看看一个 H5 普通长列表在 iOS 系统下（开启了滚动回弹）的滚动表现： weui 的 picker 组件 明显可见，weui 选择器的惯性滚动效果非常弱，基本上手从屏幕上移开后滚动就很快停止了，体验较为不好。 vant 的 picker 组件 相比之下，vant 选择器的惯性滚动效果则明显清晰得多，但是由于触顶/底回弹时依然维持了普通滚动时的系数或持续时间，导致整体来说回弹的效果有点脱节。 应用物理学模型惯性 一词来源于物理学中的惯性定律（即 牛顿第一定律）：一切物体在没有受到力的作用的时候，运动状态不会发生改变，物体所拥有的这种性质就被称为惯性。可想而知，惯性滚动的本质就是物理学中的惯性现象，因此，我们可以恰当利用中学物理上的 滑块模型 来描述惯性滚动全过程。 为了方便描述，我们把浏览器惯性滚动效果中的滚动目标（如浏览器中的页面元素）模拟成滑块模型中的 滑块。而且分析得出，惯性滚动的全过程可以模拟为（人）使滑块滑动一定距离然后释放的过程，那么，全流程可以拆解为以下两个阶段： 第一阶段，滑动滑块使其从静止开始做加速运动； 在此阶段，滑块受到的 F拉 大于 F摩 使其从左到右匀加速前进。 需要注意的是，对于浏览器的惯性滚动来说，我们一般关注的是用户即将释放手指前的一小阶段，而非滚动的全流程（全流程意义不大），这一瞬间阶段可以简单模拟为滑块均衡受力做 匀加速运动。 第二阶段，释放滑块使其在只受摩擦力的作用下继续滑动，直至最终静止； 在此阶段，滑块只受到反向的摩擦力，会维持从左到右的运动方向减速前进然后停下。 基于滑块模型，我们需要找到适合的量化指标来建立惯性滚动的计算体系。结合模型和具体实现，我们需要关注 滚动距离、速度曲线 以及 滚动时长 这几个关键指标，下面会一一展开解析。 滚动距离对于滑动模型的第一阶段，滑块做匀加速运动，我们不妨设滑块的滑动距离为 s1，滑动的时间为 t1，结束时的临界点速度（末速度）为 v1 ，根据位移公式 可以得出速度关系 对于第二阶段，滑块受摩擦力 F拉 做匀减速运动，我们不妨设滑动距离为 s2，滑动的时间为 t2，滑动加速度为 a，另外初速度为 v1，末速度为 0m/s，结合位移公式和加速度公式 可以推算出滑动距离 s2 由于匀减速运动的加速度为负（即 a &lt; 0），不妨设一个加速度常量 A，使其满足 A = -2a 的关系，那么滑动距离 然而在浏览器实际应用时，v1 算平方会导致最终计算出的惯性滚动距离太大（即对滚动手势的强度感应过于灵敏），我们不妨把平方运算去掉： 所以，求惯性滚动的距离（即 s2）时，我们只需要记录用户滚动的 距离 s1 和 滚动时长 t1，并设置一个合适的 加速度常量 A 即可。 经大量测试得出，加速度常量 A 的合适值为 0.003。 另外，需要注意的是，对于真正的浏览器惯性滚动效果来说，这里讨论的滚动距离和时长是指能够作用于惯性滚动的范围内的距离和时长，而非用户滚动页面元素的全流程，详细的可以看【启停条件】这一节内容。 惯性滚动速度曲线针对惯性滚动阶段，也就是第二阶段中的匀减速运动，根据位移公式可以得到位移差和时间间距 T 的关系 不难得出，在同等时间间距条件下，相邻两段位移差会越来越小，换句话说就是惯性滚动的偏移量增加速度会越来越小。这与 CSS3 transition-timing-function 中的 ease-out 速度曲线非常吻合，ease-out （即 cubic-bezier(0, 0, .58, 1)）的贝塞尔曲线为 曲线图来自 在线绘制贝塞尔曲线网站。 其中，图表中的纵坐标是指 动画推进的进程，横坐标是指 时间，原点坐标为 (0, 0)，终点坐标为 (1, 1)，假设动画持续时间为 2 秒，(1, 1) 坐标点则代表动画启动后 2 秒时动画执行完毕（100%）。根据图表可以得出，时间越往后动画进程的推进速度越慢，符合匀减速运动的特性。 我们试试实践应用 ease-out 速度曲线： 很明显，这样的速度曲线过于线性平滑，减速效果不明显。我们参考 iOS 滚动回弹的效果重复测试，调整贝塞尔曲线的参数为 cubic-bezier(.17, .89, .45, 1)： 调整曲线后的效果理想很多： 回弹接下来模拟惯性滚动时触碰到容器边界触发回弹的情况。 我们基于滑块模型来模拟这样的场景：滑块左端与一根弹簧连接，弹簧另一端固定在墙体上，在滑块向右滑动的过程中，当滑块到达临界点（弹簧即将发生形变时）而速度还没有降到 0m/s 时，滑块会继续滑动并拉动弹簧使其发生形变，同时滑块会受到弹簧的反拉力作减速运动（动能转化为内能）；当滑块速度降为 0m/s 时，此时弹簧的形变量最大，由于弹性特质弹簧会恢复原状（内能转化成动能），并拉动滑块反向（左）运动。 类似地，回弹过程也可以分为下面两个阶段： 滑块拉动弹簧往右做变减速运动； 此阶段滑块受到摩擦力 F摩 和越来越大的弹簧拉力 F弹 共同作用，加速度越来越大，导致速度降为 0m/s 的时间会非常短。 弹簧恢复原状，拉动滑块向左做先变加速后变减速运动； 此阶段滑块受到的摩擦力 F摩 和越来越小的弹簧拉力 F弹 相互抵消，刚开始 F弹 &gt; F摩，滑块做加速度越来越小的变加速运动；随后 F弹 &lt; F摩，滑块做加速度越来越大的变减速运动，直至最终静止。这里为了方便实际计算，我们不妨假设一个理想状态：当滑块静止时弹簧刚好恢复形变。 回弹距离根据上面的模型分析，回弹的第一阶段做加速度越来越大的变减速直线运动，不妨设此阶段的初速度为 v0，末速度为 v1，那么可以与滑块位移建立关系： 其中 a 为加速度变量，这里暂不展开讨论。那么，根据物理学的弹性模型，第二阶段的回弹距离为 微积分都来了，简直没法计算…… 然而，我们可以根据运动模型适当简化 S回弹 值的计算。由于 回弹第二阶段的加速度 是大于 非回弹惯性滚动阶段的加速度（F弹 + F摩 &gt; F摩）的，不妨设非回弹惯性滚动阶段的总距离为 S滑，那么 因此，我们可以设置一个较为合理的常量 B，使其满足这样的等式： 经大量实践得出，常量 B 的合理值为 10。 回弹速度曲线触发回弹的整个惯性滚动轨迹可以拆分成三个运动阶段： 然而，如果要把阶段 a 和阶段 b 准确描绘成 CSS 动画是有很高的复杂度的： 阶段 b 中的变减速运动难以准确描绘； 这两个阶段虽运动方向相同但动画速度曲线不连贯，很容易造成用户体验断层； 为了简化流程，我们把阶段 a 和 b 合并成一个运动阶段，那么简化后的轨迹就变成： 鉴于在阶段 a 末端的反向加速度会越来越大，所以此阶段滑块的速度骤减同比非回弹惯性滚动更快，对应的贝塞尔曲线末端就会更陡。我们选择一条较为合理的曲线 cubic-bezier(.25, .46, .45, .94)： 对于阶段 b，滑块先变加速后变减速，与 ease-in-out 的曲线有点类似，实践尝试： 仔细观察，我们发现阶段 a 和阶段 b 的衔接不够流畅，这是由于 ease-in-out 曲线的前半段缓入导致的。所以，为了突出效果我们选择只描绘变减速运动的阶段 b 末段。贝塞尔曲线调整为 cubic-bezier(.165, .84, .44, 1) 实践效果： 由于 gif 转格式导致部分掉帧，示例效果看起来会有点卡顿，建议直接体验 demo CSS 动效时长我们对 iOS 的滚动回弹效果做多次测量，定义出体验良好的动效时长参数。在一次惯性滚动中，可能会出现下面两种情况，对应的动效时间也不一样： 没有触发回弹 惯性滚动的合理持续时间为 2500ms。 触发回弹 对于阶段 a，当 S回弹 大于某个关键阈值时定义为 强回弹，动效时长为 400ms；反之则定义为 弱回弹，动效时长为 800ms。 而对于阶段 b，反弹的持续时间为 500ms 较为合理。 启停条件前文中有提到，如果把用户滚动页面元素的整个过程都纳入计算范围是非常不合理的。不难想象，当用户以非常缓慢的速度使元素滚动比较大的距离，这种情况下元素动量非常小，理应不触发惯性滚动。因此，惯性滚动的触发是有条件的。 启动条件 惯性滚动的启动需要有足够的动量。我们可以简单地认为，当用户滚动的距离足够大（大于 15px）和持续时间足够短（小于 300ms）时，即可产生惯性滚动。换成编程语言就是，最后一次 touchmove 事件触发的时间和 touchend 事件触发的时间间隔小于 300ms，且两者产生的距离差大于 15px 时认为可启动惯性滚动。 暂停时机 当惯性滚动未结束（包括处于回弹过程），用户再次触碰滚动元素时，我们应该暂停元素的滚动。在实现原理上，我们需要通过 getComputedStyle 和 getPropertyValue 方法获取当前的 transform: matrix() 矩阵值，抽离出元素的水平 y 轴偏移量后重新调整 translate 的位置。 示例代码基于 vuejs 提供了部分关键代码，也可以直接访问 codepen demo 体验效果（完整代码）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159&lt;html&gt; &lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;template id=\"tpl\"&gt; &lt;div ref=\"wrapper\" @touchstart.prevent=\"onStart\" @touchmove.prevent=\"onMove\" @touchend.prevent=\"onEnd\" @touchcancel.prevent=\"onEnd\" @transitionend=\"onTransitionEnd\"&gt; &lt;ul ref=\"scroller\" :style=\"scrollerStyle\"&gt; &lt;li v-for=\"item in list\"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; new Vue(&#123; el: '#app', template: '#tpl', computed: &#123; list() &#123;&#125;, scrollerStyle() &#123; return &#123; 'transform': `translate3d(0, $&#123;this.offsetY&#125;px, 0)`, 'transition-duration': `$&#123;this.duration&#125;ms`, 'transition-timing-function': this.bezier, &#125;; &#125;, &#125;, data() &#123; return &#123; minY: 0, maxY: 0, wrapperHeight: 0, duration: 0, bezier: 'linear', pointY: 0, // touchStart 手势 y 坐标 startY: 0, // touchStart 元素 y 偏移值 offsetY: 0, // 元素实时 y 偏移值 startTime: 0, // 惯性滑动范围内的 startTime momentumStartY: 0, // 惯性滑动范围内的 startY momentumTimeThreshold: 300, // 惯性滑动的启动 时间阈值 momentumYThreshold: 15, // 惯性滑动的启动 距离阈值 isStarted: false, // start锁 &#125;; &#125;, mounted() &#123; this.$nextTick(() =&gt; &#123; this.wrapperHeight = this.$refs.wrapper.getBoundingClientRect().height; this.minY = this.wrapperHeight - this.$refs.scroller.getBoundingClientRect().height; &#125;); &#125;, methods: &#123; onStart(e) &#123; const point = e.touches ? e.touches[0] : e; this.isStarted = true; this.duration = 0; this.stop(); this.pointY = point.pageY; this.momentumStartY = this.startY = this.offsetY; this.startTime = new Date().getTime(); &#125;, onMove(e) &#123; if (!this.isStarted) return; const point = e.touches ? e.touches[0] : e; const deltaY = point.pageY - this.pointY; this.offsetY = Math.round(this.startY + deltaY); const now = new Date().getTime(); // 记录在触发惯性滑动条件下的偏移值和时间 if (now - this.startTime &gt; this.momentumTimeThreshold) &#123; this.momentumStartY = this.offsetY; this.startTime = now; &#125; &#125;, onEnd(e) &#123; if (!this.isStarted) return; this.isStarted = false; if (this.isNeedReset()) return; const absDeltaY = Math.abs(this.offsetY - this.momentumStartY); const duration = new Date().getTime() - this.startTime; // 启动惯性滑动 if (duration &lt; this.momentumTimeThreshold &amp;&amp; absDeltaY &gt; this.momentumYThreshold) &#123; const momentum = this.momentum(this.offsetY, this.momentumStartY, duration); this.offsetY = Math.round(momentum.destination); this.duration = momentum.duration; this.bezier = momentum.bezier; &#125; &#125;, onTransitionEnd() &#123; this.isNeedReset(); &#125;, momentum(current, start, duration) &#123; const durationMap = &#123; 'noBounce': 2500, 'weekBounce': 800, 'strongBounce': 400, &#125;; const bezierMap = &#123; 'noBounce': 'cubic-bezier(.17, .89, .45, 1)', 'weekBounce': 'cubic-bezier(.25, .46, .45, .94)', 'strongBounce': 'cubic-bezier(.25, .46, .45, .94)', &#125;; let type = 'noBounce'; // 惯性滑动加速度 const deceleration = 0.003; // 回弹阻力 const bounceRate = 10; // 强弱回弹的分割值 const bounceThreshold = 300; // 回弹的最大限度 const maxOverflowY = this.wrapperHeight / 6; let overflowY; const distance = current - start; const speed = 2 * Math.abs(distance) / duration; let destination = current + speed / deceleration * (distance &lt; 0 ? -1 : 1); if (destination &lt; this.minY) &#123; overflowY = this.minY - destination; type = overflowY &gt; bounceThreshold ? 'strongBounce' : 'weekBounce'; destination = Math.max(this.minY - maxOverflowY, this.minY - overflowY / bounceRate); &#125; else if (destination &gt; this.maxY) &#123; overflowY = destination - this.maxY; type = overflowY &gt; bounceThreshold ? 'strongBounce' : 'weekBounce'; destination = Math.min(this.maxY + maxOverflowY, this.maxY + overflowY / bounceRate); &#125; return &#123; destination, duration: durationMap[type], bezier: bezierMap[type], &#125;; &#125;, // 超出边界时需要重置位置 isNeedReset() &#123; let offsetY; if (this.offsetY &lt; this.minY) &#123; offsetY = this.minY; &#125; else if (this.offsetY &gt; this.maxY) &#123; offsetY = this.maxY; &#125; if (typeof offsetY !== 'undefined') &#123; this.offsetY = offsetY; this.duration = 500; this.bezier = 'cubic-bezier(.165, .84, .44, 1)'; return true; &#125; return false; &#125;, // 停止滚动 stop() &#123; const matrix = window.getComputedStyle(this.$refs.scroller).getPropertyValue('transform'); this.offsetY = Math.round(+matrix.split(')')[0].split(', ')[5]); &#125;, &#125;, &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 参考资料 weui-picker better-scroll","pubDate":"Mon, 08 Jun 2020 16:00:00 GMT","guid":"https://aotu.io/notes/2020/06/08/momentum-scrolling/","category":"web 开发"},{"title":"从 SQL 到 MongoDB 之聚合篇","link":"https://aotu.io/notes/2020/06/07/sql-to-mongo-2/","description":"翻译原文：MongoDB 官方文档： SQL to Aggregation Mapping Chart 在上一篇翻译 从 SQL 到 MongoDB 之概念篇，我们详细讲解了 SQL 和 MongoDB 的一些概念的对应关系，方便大家入门和理解，这一篇属于进阶篇，主要讲解了 SQL 和 MongoDB 和 数据聚合 的对应关系。 聚合管道 （aggregation pipeline ） 让 MongoDB 提供与 SQL 中的许多常见数据聚合操作相对应的，原生的聚合功能。 下表概述了常见的 SQL 聚合术语、函数和概念以及相应的 MongoDB 聚合操作符（aggregation operators）： SQL 术语、函数和概念 MongoDB 聚合操作符 WHERE $match GROUP BY $group HAVING $match SELECT $project ORDER BY $sort LIMIT $limit SUM() $sum COUNT() $sum $sortByCount join $lookup SELECT INTO NEW_TABLE $out MERGE INTO TABLE $merge MongoDB 4.2 可用 有关所有聚合管道和表达式操作符的列表，请参见：Aggregation Pipeline Quick Reference。 另见：SQL to MongoDB Mapping Chart Examples下面提供了 SQL 聚合语句和相应的 MongoDB 语句，表中的例子假定以下条件： SQL 示例假定有两个表：orders 和 order_lineitem，然后通过 order_lineitem.order_id 和 orders.id 进行 join 操作。 MongoDB 示例假设其中一个集合（collection） orders 包含以下原型的文档（documents）： 12345678&#123; cust_id: \"abc123\", ord_date: ISODate(\"2012-11-02T17:04:11.102Z\"), status: 'A', price: 50, items: [ &#123; sku: \"xxx\", qty: 25, price: 1 &#125;, &#123; sku: \"yyy\", qty: 25, price: 1 &#125; ]&#125; COUNT vs count计算所有 orders 记录数量： SQL 示例 12SELECT COUNT(*) AS countFROM orders MongoDB 示例 12345678db.orders.aggregate( [ &#123; $group: &#123; _id: null, count: &#123; $sum: 1 &#125; &#125; &#125;] ) SUM vs $sum计算 orders 中 price 的总和： SQL 示例 12SELECT SUM(price) AS totalFROM orders MongoDB 示例 12345678db.orders.aggregate( [ &#123; $group: &#123; _id: null, total: &#123; $sum: \"$price\" &#125; &#125; &#125;] ) GROUP BY vs $group对于每一个独特的 cust_id，计算 price 字段总和： SQL 示例 1234SELECT cust_id, SUM(price) AS totalFROM ordersGROUP BY cust_id MongoDB 示例 12345678db.orders.aggregate( [ &#123; $group: &#123; _id: \"$cust_id\", total: &#123; $sum: \"$price\" &#125; &#125; &#125;] ) ORDER BY vs $sort对于每一个独特的 cust_id，计算 price 字段总和，且结果按总和排序： SQL 示例 12345SELECT cust_id, SUM(price) AS totalFROM ordersGROUP BY cust_idORDER BY total MongoDB 示例 123456789db.orders.aggregate( [ &#123; $group: &#123; _id: \"$cust_id\", total: &#123; $sum: \"$price\" &#125; &#125; &#125;, &#123; $sort: &#123; total: 1 &#125; &#125;] ) GROUP BY Multi对于每一个独特的 cust_id，按照 ord_date 进行分组，且不包含日期的时间部分，计算 price 字段总和。 SQL 示例 123456SELECT cust_id, ord_date, SUM(price) AS totalFROM ordersGROUP BY cust_id, ord_date MongoDB 示例 1234567891011121314db.orders.aggregate( [ &#123; $group: &#123; _id: &#123; cust_id: \"$cust_id\", ord_date: &#123; $dateToString: &#123; format: \"%Y-%m-%d\", date: \"$ord_date\" &#125;&#125; &#125;, total: &#123; $sum: \"$price\" &#125; &#125; &#125;] ) HAVING vs $match对于 cust_id 如果有多个记录，就返回 cust_id 以及相应的记录数量： SQL 示例 123456SELECT cust_id, count(*)FROM ordersGROUP BY cust_idHAVING count(*) &gt; 1 MongoDB 示例 123456789db.orders.aggregate( [ &#123; $group: &#123; _id: \"$cust_id\", count: &#123; $sum: 1 &#125; &#125; &#125;, &#123; $match: &#123; count: &#123; $gt: 1 &#125; &#125; &#125;] ) WHERE vs $match对于每一个独特的 cust_id，且 status = ‘A’，计算 price 字段总和，只有在总和大于 250 的情况下，才可以返回。 SQL 示例 123456SELECT cust_id, SUM(price) as totalFROM ordersWHERE status = 'A'GROUP BY cust_idHAVING total &gt; 250 MongoDB 示例 12345678910db.orders.aggregate( [ &#123; $match: &#123; status: 'A' &#125; &#125;, &#123; $group: &#123; _id: \"$cust_id\", total: &#123; $sum: \"$price\" &#125; &#125; &#125;, &#123; $match: &#123; total: &#123; $gt: 250 &#125; &#125; &#125;] ) $unwind对于每一个独特的 cust_id，对相应的行的 item 项求和得到 qty： SQL 示例 123456SELECT cust_id, SUM(li.qty) as qtyFROM orders o, order_lineitem liWHERE li.order_id = o.idGROUP BY cust_id MongoDB 示例 123456789db.orders.aggregate( [ &#123; $unwind: \"$items\" &#125;, &#123; $group: &#123; _id: \"$cust_id\", qty: &#123; $sum: \"$items.qty\" &#125; &#125; &#125;] ) Multi aggregate将 cust_id, ord_date 分组并计算数量 ，不包括日期的时间部分。 1234567SELECT COUNT(*)FROM (SELECT cust_id, ord_date FROM orders GROUP BY cust_id, ord_date) as DerivedTable 12345678910111213141516171819db.orders.aggregate( [ &#123; $group: &#123; _id: &#123; cust_id: \"$cust_id\", ord_date: &#123; $dateToString: &#123; format: \"%Y-%m-%d\", date: \"$ord_date\" &#125;&#125; &#125; &#125; &#125;, &#123; $group: &#123; _id: null, count: &#123; $sum: 1 &#125; &#125; &#125;] ) 另见 SQL to MongoDB Mapping Chart Aggregation Pipeline Quick Reference db.collection.aggregate()","pubDate":"Sun, 07 Jun 2020 16:00:00 GMT","guid":"https://aotu.io/notes/2020/06/07/sql-to-mongo-2/","category":"全栈开发"},{"title":"从 SQL 到 MongoDB 之概念篇","link":"https://aotu.io/notes/2020/06/07/sql-to-mongo-1/","description":"翻译原文：MongoDB 官方文档：SQL to MongoDB Mapping Chart 前言很多开发者首次接触数据库（通常是在高校课堂）的概念，或者说接触第一个数据库，通常是 SQL 数据库，而现在，NoSQL 数据库越来越流行，很多原 SQL 数据的使用者难免有转向 NoSQL 的需求。而作为 NoSQL 数据库的代表，MongoDB 在社区越来越流行，生产环境的使用也日益广泛。 对于 SQL 转战 NoSQL的开发人员来说，最难的一步其实是将原有的 SQL 的概念和知识直接复用过来，最大化的减小学习的成本。 其实，这一步 MongoDB 官方已经为大家考虑到了，那就是在：MongoDB CRUD Operations &gt; MongoDB CRUD Operations &gt; SQL to MongoDB Mapping Chart，这篇文档非常好的总结了 SQL 对应 MongoDB 的术语和概念，还有可执行文件、SQL 语句/MongoDB 语句等， 可以说对于 SQL 数据库开发人员，如果理解了他们之间的对应关系，那么就一只脚就迈进了 MongoDB 的大门。 Terminology and Concepts下表介绍了各种 SQL 术语和概念以及相应的 MongoDB 术语和概念. SQL术语/概念 MongoDB 术语/概念 database database table collection row document 或 BSON document column field index index table joins （表联接） $lookup, embedded documents （嵌入式文档） primary key 指定任何唯一的列或者列组合作为主键 primary key 在 MongoDB 中, 主键自动设置为 _id 字段 aggregation (如：group by) aggregation pipeline （聚合管道）参考：SQL to Aggregation Mapping Chart SELECT INTO NEW_TABLE $out 参考： SQL to Aggregation Mapping Chart MERGE INTO TABLE $merge （从MongoDB 4.2开始可用） 参考：SQL to Aggregation Mapping Chart transactions transactions TIP 在许多情况下， 非规范化数据模型（嵌入式文档和数组） denormalized data model (embedded documents and arrays) 将继续是您数据和用例的最佳选择，而不是多文档事务. 也就是说，对于许多场景，对数据进行适当的建模将最大限度地减少对 多文档事务（multi-document transactions）的需求。 Executables下表显示了一些数据库可执行文件和相应的 MongoDB 可执行文件。 这张表并不是详尽无遗的。 MongoDB MySQL Oracle Informix DB2 Database Server mongod mysqld oracle IDS DB2 Server Database Client mongo mysql sqlplus DB-Access DB2 Client Examples下表显示了各种 SQL 语句和相应的 MongoDB 语句。 表中的例子假定以下条件: Sql 示例假设一个名为 people 的表。 MongoDB 的示例假定一个名为 people 的集合包含以下原型的文档： 123456&#123; _id: ObjectId(\"509a8fb2f3f4948bd2f983a0\"), user_id: \"abc123\", age: 55, status: 'A'&#125; Create and AlterCREATE TABLE SQL 模式语句： 12345678CREATE TABLE people ( id MEDIUMINT NOT NULL AUTO_INCREMENT, user_id Varchar(30), age Number, status char(1), PRIMARY KEY (id)) MongoDB 模式语句： 12345db.people.insertOne( &#123; user_id: \"abc123\", age: 55, status: \"A\" &#125; ) 在第一个 insertOne() 或 insertMany() 操作上隐式创建。 如果没有指定 _id 字段，则自动添加主键 _id。 但是，您也可以显式地创建一个集合： 1db.createCollection(\"people\") ALTER TABLE / ADD SQL模式语句： 12ALTER TABLE peopleADD join_date DATETIME MongoDB 模式语句： 1234db.people.updateMany( &#123; &#125;, &#123; $set: &#123; join_date: new Date() &#125; &#125;) 集合不描述或强制执行其文档的结构；也就是说，在集合级别上没有结构上的改变。 但是，在文档级别，updateMany() 操作可以使用 $set 操作符向现有文档添加字段。 ALTER TABLE / DROP COLUMN SQL模式语句： 12ALTER TABLE peopleDROP COLUMN join_date MongoDB 模式语句： 1234db.people.updateMany( &#123; &#125;, &#123; $unset: &#123; \"join_date\": \"\" &#125; &#125;) 集合不描述或强制执行其文档的结构；也就是说，在集合级别上没有结构上的改变。 但是，在文档级别，updateMany() 操作可以使用 $unset 操作符从文档中删除字段。 CREATE INDEX SQL 模式语句： 12CREATE INDEX idx_user_id_ascON people(user_id) MongoDB 模式语句： 1db.people.createIndex( &#123; user_id: 1 &#125; ) CREATE INDEX / Multi SQL模式语句： 123CREATE INDEX idx_user_id_asc_age_descON people(user_id, age DESC) MongoDB 模式语句： 1db.people.createIndex( &#123; user_id: 1, age: -1 &#125; ) DROP TABLE SQL模式语句： 1DROP TABLE people MongoDB 模式语句： 1db.people.drop() 更多有关使用的方法和操作符的详细信息，请参阅: db.collection.insertOne() db.collection.insertMany() db.createCollection() db.collection.updateMany() db.collection.createIndex() db.collection.drop() $set $unset 另见： Databases and Collections Documents Indexes Data Modeling Concepts Insert下表显示了与向表中插入记录相关的各种 SQL 语句以及相应的 MongoDB 语句。 SQL INSERT 语句 123456INSERT INTO people(user_id, age, status)VALUES (\"bcd001\", 45, \"A\") Mongodb insertOne() 语句 123db.people.insertOne( &#123; user_id: \"bcd001\", age: 45, status: \"A\" &#125;) 有关更多信息，请参见 db.collection.insertOne()。 另见： Insert Documents db.collection.insertMany() Databases and Collections Documents Select下表显示了与从表中读取记录相关的各种 SQL 语句以及相应的 MongoDB 语句。 NOTE： find() 方法总是包含返回文档中的 _id 字段，除非通过 projection 特别排除。 下面的一些 SQL 查询可能包含一个 _id 字段来反映这一点，即使该字段没有包含在相应的 find() 查询中。 SELECT … WHERE SQL 语句 1234SELECT user_id, statusFROM peopleWHERE status = \"A\" Mongodb 语句 1234db.people.find( &#123; status: \"A\" &#125;, &#123; user_id: 1, status: 1, _id: 0 &#125;) SELECT … AND SQL 语句 1234SELECT *FROM peopleWHERE age &gt; 25AND age &lt;= 50 Mongodb 语句 123db.people.find( &#123; age: &#123; $gt: 25, $lte: 50 &#125; &#125;) SELECT … OR SQL 语句 1234SELECT *FROM peopleWHERE status = \"A\"OR age = 50 Mongodb 语句 123db.people.find( &#123; $or: [ &#123; status: \"A\" &#125; , &#123; age: 50 &#125; ] &#125;) SELECT … LIKE SQL 语句 12FROM peopleWHERE user_id like \"%bc%\" Mongodb 语句 12345db.people.find( &#123; user_id: /bc/ &#125; )-or-db.people.find( &#123; user_id: &#123; $regex: /bc/ &#125; &#125; ) SELECT … OEDER BY SQL 语句 1234SELECT *FROM peopleWHERE status = \"A\"ORDER BY user_id ASC Mongodb 语句 1db.people.find( &#123; status: \"A\" &#125; ).sort( &#123; user_id: 1 &#125; ) SELECT … COUNT SQL 语句 12SELECT COUNT(user_id)FROM people Mongodb 语句 12345db.people.count( &#123; user_id: &#123; $exists: true &#125; &#125; )ordb.people.find( &#123; user_id: &#123; $exists: true &#125; &#125; ).count() SELECT DISTINCT SQL 语句 12SELECT DISTINCT(status)FROM people Mongodb 语句 123456db.people.aggregate( [ &#123; $group : &#123; _id : \"$status\" &#125; &#125; ] )或者，对于不同的不超过 [BSON 大小限制](https://docs.mongodb.com/manual/reference/limits/#limit-bson-document-size) 的值集db.people.distinct( \"status\" ) SELECT … LIMIT SKIP SQL 语句 1234SELECT *FROM peopleLIMIT 5SKIP 10 Mongodb 语句 1db.people.find().limit(5).skip(10) EXPLAIN SELECT SQL 语句 123EXPLAIN SELECT *FROM peopleWHERE status = \"A\" Mongodb 语句 1db.people.find( &#123; status: \"A\" &#125; ).explain() 有关所使用的方法的详细信息，请参阅： db.collection.find() db.collection.distinct() db.collection.findOne() limit() skip() explain() sort() count() 运算符（operators）： $ne $and $or $gt $lt $exists $lte $regex 另见： Query Documents Query and Projection Operators mongo Shell Methods Update Records下面显示了与更新表中现有记录相关的各种 SQL 语句以及相应的 MongoDB 语句。 UPDATE … SET SQL 语句 123UPDATE peopleSET status = \"C\"WHERE age &gt; 25 Mongodb 语句 1234db.people.updateMany( &#123; age: &#123; $gt: 25 &#125; &#125;, &#123; $set: &#123; status: \"C\" &#125; &#125;) UPDATE … INC SQL 语句 123UPDATE peopleSET age = age + 3WHERE status = \"A\" Mongodb 语句 1234db.people.updateMany( &#123; status: \"A\" &#125; , &#123; $inc: &#123; age: 3 &#125; &#125;) 有关示例中使用的方法和运算符的详细信息，请参阅： db.collection.updateMany() $gt $set $inc 另见： Update Documents Update Operators db.collection.updateOne() db.collection.replaceOne() Delete Records下面显示了与从表中删除记录相关的各种 SQL 语句以及相应的 MongoDB 语句。 DELETE WHERE SQL 语句 12DELETE FROM peopleWHERE status = \"D\" Mongodb 语句 1db.people.deleteMany( &#123; status: \"D\" &#125; ) DELETE SQL 语句 1DELETE FROM people Mongodb 语句 1db.people.deleteMany(&#123;&#125;) 有关更多信息，请参见 db.collection.deleteMany()。 Delete Documents db.collection.deleteOne() 看到这里，想必大家应该已经将脑海中 SQL 相关的知识和 MongoDB 一一对应起来了，那么剩下的就需要大家多多的实践，深入挖掘。 但是无论何时，都要记住，MongoDB 官方文档 绝对是你能找到的最权威、最全面的资料。","pubDate":"Sun, 07 Jun 2020 16:00:00 GMT","guid":"https://aotu.io/notes/2020/06/07/sql-to-mongo-1/","category":"全栈开发"}]}